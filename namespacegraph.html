<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>SPIDER: graph Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">SPIDER
   </div>
   <div id="projectbrief">A graph visualization framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacegraph.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">graph Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="apsp_8hpp_source.html">apsp.hpp</a> - Header file that has collection of all pair shortest path finding algorithms  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacegraph_1_1gen"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraph_1_1gen.html">gen</a></td></tr>
<tr class="memdesc:namespacegraph_1_1gen"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="generate_8hpp_source.html">generate.hpp</a> - Contains a library of standard graphs <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraph_1_1_adjacency_list.html">AdjacencyList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>class to store adjacency list of a graph </li>
</ul>
 <a href="classgraph_1_1_adjacency_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraph_1_1_a_p_s_p_state.html">APSPState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Class to hold the current state of the required datastructures during an APSP algorithm. </li>
</ul>
 <a href="classgraph_1_1_a_p_s_p_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraph_1_1_color_state.html">ColorState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Class to hold the current state of the required datastructures during any graph coloring algorithm. </li>
</ul>
 <a href="classgraph_1_1_color_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraph_1_1_disjoint_set.html">DisjointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Class to implement disjoint set datastructure using union by rank. </li>
</ul>
 <a href="classgraph_1_1_disjoint_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraph_1_1_distance_array.html">DistanceArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Class for distance array datastructure. Contains a <a class="el" href="classgraph_1_1_vertex_attribute.html" title="class that contains Vertex attributes ">VertexAttribute</a> which maps each vertex to distance. </li>
</ul>
 <a href="classgraph_1_1_distance_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1edge__traits.html">edge_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>defines a structure of edge traits with vertex type </li>
</ul>
 <a href="structgraph_1_1edge__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1edge__traits_3_01int_01_4.html">edge_traits&lt; int &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>defines a structure of edge traits with long </li>
</ul>
 <a href="structgraph_1_1edge__traits_3_01int_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraph_1_1_edge_attribute.html">EdgeAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>class that contains Edge attributes </li>
</ul>
 <a href="classgraph_1_1_edge_attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraph_1_1_graph_attribute.html">GraphAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>class that contains graph attributes </li>
</ul>
 <a href="classgraph_1_1_graph_attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraph_1_1_m_s_t_state.html">MSTState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Class to hold the current state of the required datastructures during a MST computing algorithm. </li>
</ul>
 <a href="classgraph_1_1_m_s_t_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraph_1_1_parent_array.html">ParentArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Class for parent array datastructure. Contains a <a class="el" href="classgraph_1_1_vertex_attribute.html" title="class that contains Vertex attributes ">VertexAttribute</a> which maps each vertex to parent. </li>
</ul>
 <a href="classgraph_1_1_parent_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraph_1_1_priority_queue.html">PriorityQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>class to implement priority queue </li>
</ul>
 <a href="classgraph_1_1_priority_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraph_1_1_queue.html">Queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Class to implment queue </li>
</ul>
 <a href="classgraph_1_1_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraph_1_1_search.html">Search</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>The basic framework to implement Graph <a class="el" href="classgraph_1_1_search.html" title="The basic framework to implement Graph Search ">Search</a> </li>
</ul>
 <a href="classgraph_1_1_search.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraph_1_1_s_s_s_p_state.html">SSSPState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Class to hold the source vertex and current state of the required datastructures during a SSSP algorithm. </li>
</ul>
 <a href="classgraph_1_1_s_s_s_p_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraph_1_1_stack.html">Stack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Class to implment stack. </li>
</ul>
 <a href="classgraph_1_1_stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraph_1_1_vertex_attribute.html">VertexAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>class that contains Vertex attributes </li>
</ul>
 <a href="classgraph_1_1_vertex_attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a37427190269c66c2c77002f344418399"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:a37427190269c66c2c77002f344418399"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a37427190269c66c2c77002f344418399">UniformCostSearch</a> = <a class="el" href="classgraph_1_1_search.html">Search</a>&lt; G, <a class="el" href="classgraph_1_1_priority_queue.html">PriorityQueue</a> &gt;</td></tr>
<tr class="memdesc:a37427190269c66c2c77002f344418399"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>To implement Uniform Cost <a class="el" href="classgraph_1_1_search.html" title="The basic framework to implement Graph Search ">Search</a> </li>
</ul>
 <a href="#a37427190269c66c2c77002f344418399">More...</a><br /></td></tr>
<tr class="separator:a37427190269c66c2c77002f344418399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4abf0b1a5f973af70d500d9ad0d5c4"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:a4e4abf0b1a5f973af70d500d9ad0d5c4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a4e4abf0b1a5f973af70d500d9ad0d5c4">DepthFirstSearch</a> = <a class="el" href="classgraph_1_1_search.html">Search</a>&lt; G, <a class="el" href="classgraph_1_1_stack.html">Stack</a> &gt;</td></tr>
<tr class="memdesc:a4e4abf0b1a5f973af70d500d9ad0d5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>To implement Depth First <a class="el" href="classgraph_1_1_search.html" title="The basic framework to implement Graph Search ">Search</a> </li>
</ul>
 <a href="#a4e4abf0b1a5f973af70d500d9ad0d5c4">More...</a><br /></td></tr>
<tr class="separator:a4e4abf0b1a5f973af70d500d9ad0d5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7989ed2355805874eadb4fd84b24f079"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7989ed2355805874eadb4fd84b24f079"></a>
template&lt;typename G &gt; </td></tr>
<tr class="memitem:a7989ed2355805874eadb4fd84b24f079"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a7989ed2355805874eadb4fd84b24f079">BreadthFirstSearch</a> = <a class="el" href="classgraph_1_1_search.html">Search</a>&lt; G, <a class="el" href="classgraph_1_1_queue.html">Queue</a> &gt;</td></tr>
<tr class="memdesc:a7989ed2355805874eadb4fd84b24f079"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>To implement Breadth First <a class="el" href="classgraph_1_1_search.html" title="The basic framework to implement Graph Search ">Search</a> Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a `search key'[1]) and explores the neighbor nodes first, before moving to the next level neighbours. Refernce Link - <a href="http://en.wikipedia.org/wiki/Breadth-first_search">BFS</a> </li>
</ul>
<br /></td></tr>
<tr class="separator:a7989ed2355805874eadb4fd84b24f079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79acfc9c3ac45e39bf873e19eff98fab"><td class="memTemplParams" colspan="2"><a class="anchor" id="a79acfc9c3ac45e39bf873e19eff98fab"></a>
template&lt;typename VertexType , typename EdgeType &gt; </td></tr>
<tr class="memitem:a79acfc9c3ac45e39bf873e19eff98fab"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> = <a class="el" href="classgraph_1_1_adjacency_list.html">AdjacencyList</a>&lt; VertexType, EdgeType &gt;</td></tr>
<tr class="memdesc:a79acfc9c3ac45e39bf873e19eff98fab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>using Graph for <a class="el" href="classgraph_1_1_adjacency_list.html">AdjacencyList&lt;VertexType,EdgeType&gt;</a> </li>
</ul>
<br /></td></tr>
<tr class="separator:a79acfc9c3ac45e39bf873e19eff98fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4a67cccc220255b81655c5306f6a9c93"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a4a67cccc220255b81655c5306f6a9c93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgraph_1_1_a_p_s_p_state.html">APSPState</a>&lt; <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a4a67cccc220255b81655c5306f6a9c93">FloydRoyWarshall</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a4a67cccc220255b81655c5306f6a9c93"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Function to implement Floyd-Roy-Warshall Algorithm </li>
</ul>
 <a href="#a4a67cccc220255b81655c5306f6a9c93">More...</a><br /></td></tr>
<tr class="separator:a4a67cccc220255b81655c5306f6a9c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00b2c13c4512574d4adc236ad14a586"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:ad00b2c13c4512574d4adc236ad14a586"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#ad00b2c13c4512574d4adc236ad14a586">VertexList</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:ad00b2c13c4512574d4adc236ad14a586"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns a list containing names of all the vertices in Graph g </li>
</ul>
 <a href="#ad00b2c13c4512574d4adc236ad14a586">More...</a><br /></td></tr>
<tr class="separator:ad00b2c13c4512574d4adc236ad14a586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8dd696bb3483de793bf5027f4f25474"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:ae8dd696bb3483de793bf5027f4f25474"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::tuple&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>, typename <a class="el" href="classgraph_1_1_adjacency_list.html#a38fb996cc38fcb1cf20fbd601594c900">Graph::EdgeType</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#ae8dd696bb3483de793bf5027f4f25474">EdgeList</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, bool duplicate=true)</td></tr>
<tr class="memdesc:ae8dd696bb3483de793bf5027f4f25474"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns a list containing of adjacent vertices with edge weights </li>
</ul>
 <a href="#ae8dd696bb3483de793bf5027f4f25474">More...</a><br /></td></tr>
<tr class="separator:ae8dd696bb3483de793bf5027f4f25474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b305c5e53f0618a9f0e9c406a4f815"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa7b305c5e53f0618a9f0e9c406a4f815"></a>
template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:aa7b305c5e53f0618a9f0e9c406a4f815"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#aa7b305c5e53f0618a9f0e9c406a4f815">sortComparison</a> (std::tuple&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>, typename <a class="el" href="classgraph_1_1_adjacency_list.html#a38fb996cc38fcb1cf20fbd601594c900">Graph::EdgeType</a> &gt; a, std::tuple&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>, typename <a class="el" href="classgraph_1_1_adjacency_list.html#a38fb996cc38fcb1cf20fbd601594c900">Graph::EdgeType</a> &gt; b)</td></tr>
<tr class="memdesc:aa7b305c5e53f0618a9f0e9c406a4f815"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>A function to compare the edges between two vertices </li>
</ul>
<br /></td></tr>
<tr class="separator:aa7b305c5e53f0618a9f0e9c406a4f815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347482999e282edb2e82de37cad981de"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a347482999e282edb2e82de37cad981de"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::tuple&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>, typename <a class="el" href="classgraph_1_1_adjacency_list.html#a38fb996cc38fcb1cf20fbd601594c900">Graph::EdgeType</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a347482999e282edb2e82de37cad981de">sortedEdgeList</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, bool duplicate=true)</td></tr>
<tr class="memdesc:a347482999e282edb2e82de37cad981de"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>eturns a list containing of adjacent vertices with edge weights </li>
</ul>
 <a href="#a347482999e282edb2e82de37cad981de">More...</a><br /></td></tr>
<tr class="separator:a347482999e282edb2e82de37cad981de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dec8a130a4c41da242b1bdd9ad254a3"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a0dec8a130a4c41da242b1bdd9ad254a3"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a0dec8a130a4c41da242b1bdd9ad254a3">DegreeMap</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a0dec8a130a4c41da242b1bdd9ad254a3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns a list containing all the vertices of Graph g alongwith the total number of edges of each vertex </li>
</ul>
 <a href="#a0dec8a130a4c41da242b1bdd9ad254a3">More...</a><br /></td></tr>
<tr class="separator:a0dec8a130a4c41da242b1bdd9ad254a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13481e0c3932354bfc5ca0cd0b3b8fa3"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a13481e0c3932354bfc5ca0cd0b3b8fa3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a13481e0c3932354bfc5ca0cd0b3b8fa3">DegreeSequence</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a13481e0c3932354bfc5ca0cd0b3b8fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns a sequence of total number of edges of all vertices in Graph g in sorted order </li>
</ul>
 <a href="#a13481e0c3932354bfc5ca0cd0b3b8fa3">More...</a><br /></td></tr>
<tr class="separator:a13481e0c3932354bfc5ca0cd0b3b8fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01eff8481121cd9a87cf25132102e240"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a01eff8481121cd9a87cf25132102e240"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>, typename <a class="el" href="classgraph_1_1_adjacency_list.html#a38fb996cc38fcb1cf20fbd601594c900">Graph::EdgeType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a01eff8481121cd9a87cf25132102e240">EcentricityList</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, bool check=true)</td></tr>
<tr class="memdesc:a01eff8481121cd9a87cf25132102e240"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns a map of all vertices in Graph g with their corresponding eccentricities </li>
</ul>
 <a href="#a01eff8481121cd9a87cf25132102e240">More...</a><br /></td></tr>
<tr class="separator:a01eff8481121cd9a87cf25132102e240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6e3be7766219c83d5820969266e9b7"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:aee6e3be7766219c83d5820969266e9b7"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#aee6e3be7766219c83d5820969266e9b7">Centre</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:aee6e3be7766219c83d5820969266e9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns a set of vertices constituting the centre in Graph g </li>
</ul>
 <a href="#aee6e3be7766219c83d5820969266e9b7">More...</a><br /></td></tr>
<tr class="separator:aee6e3be7766219c83d5820969266e9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae686ba4060d119ff11440eca676fcbf"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:aae686ba4060d119ff11440eca676fcbf"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#aae686ba4060d119ff11440eca676fcbf">Periphery</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:aae686ba4060d119ff11440eca676fcbf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns a set of vertices constituting the periphery in Graph g </li>
</ul>
 <a href="#aae686ba4060d119ff11440eca676fcbf">More...</a><br /></td></tr>
<tr class="separator:aae686ba4060d119ff11440eca676fcbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f650908c1e8e62e32c991cf454682ba"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a3f650908c1e8e62e32c991cf454682ba"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; std::pair&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> &gt;, typename <a class="el" href="classgraph_1_1_adjacency_list.html#a38fb996cc38fcb1cf20fbd601594c900">Graph::EdgeType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a3f650908c1e8e62e32c991cf454682ba">AdjacencyMatrix</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a3f650908c1e8e62e32c991cf454682ba"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns adjacency matrix of Graph g </li>
</ul>
 <a href="#a3f650908c1e8e62e32c991cf454682ba">More...</a><br /></td></tr>
<tr class="separator:a3f650908c1e8e62e32c991cf454682ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13634637f492ab1746d0bf62771116a7"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a13634637f492ab1746d0bf62771116a7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a13634637f492ab1746d0bf62771116a7">OutVertexList</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> x)</td></tr>
<tr class="memdesc:a13634637f492ab1746d0bf62771116a7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns a list containing all the vertices of Graph g having edges originating from Vertex x </li>
</ul>
 <a href="#a13634637f492ab1746d0bf62771116a7">More...</a><br /></td></tr>
<tr class="separator:a13634637f492ab1746d0bf62771116a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656e6ef2a2bc5570745b2c5be0d8c53e"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a656e6ef2a2bc5570745b2c5be0d8c53e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a656e6ef2a2bc5570745b2c5be0d8c53e">InVertexList</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> x)</td></tr>
<tr class="memdesc:a656e6ef2a2bc5570745b2c5be0d8c53e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns a list containing all vertices of Graph g having edges ending at Vertex x </li>
</ul>
 <a href="#a656e6ef2a2bc5570745b2c5be0d8c53e">More...</a><br /></td></tr>
<tr class="separator:a656e6ef2a2bc5570745b2c5be0d8c53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eaa9849e824b0835a601917cb41034c"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a0eaa9849e824b0835a601917cb41034c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgraph_1_1_vertex_attribute.html">VertexAttribute</a>&lt; <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a0eaa9849e824b0835a601917cb41034c">minVertexColorAssignment</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a0eaa9849e824b0835a601917cb41034c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns a mapping of vertices and their corresponding colours </li>
</ul>
 <a href="#a0eaa9849e824b0835a601917cb41034c">More...</a><br /></td></tr>
<tr class="separator:a0eaa9849e824b0835a601917cb41034c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662e07d0caaf6aab284fb82cc3af5c2f"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a662e07d0caaf6aab284fb82cc3af5c2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgraph_1_1_vertex_attribute.html">VertexAttribute</a>&lt; <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a662e07d0caaf6aab284fb82cc3af5c2f">VertexColorAssignment</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a662e07d0caaf6aab284fb82cc3af5c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns a mapping of vertices and their corresponding colours </li>
</ul>
 <a href="#a662e07d0caaf6aab284fb82cc3af5c2f">More...</a><br /></td></tr>
<tr class="separator:a662e07d0caaf6aab284fb82cc3af5c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75483eb787f441ecd15fab9dee7f95a3"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a75483eb787f441ecd15fab9dee7f95a3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a75483eb787f441ecd15fab9dee7f95a3">EulerianCircuit</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g, bool isStartGiven=false, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> start=1)</td></tr>
<tr class="memdesc:a75483eb787f441ecd15fab9dee7f95a3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns an Eulerian Circuit of a graph </li>
</ul>
 <a href="#a75483eb787f441ecd15fab9dee7f95a3">More...</a><br /></td></tr>
<tr class="separator:a75483eb787f441ecd15fab9dee7f95a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408865b98504ee5a16776610216adacf"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a408865b98504ee5a16776610216adacf"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a408865b98504ee5a16776610216adacf">EulerianTrail</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g)</td></tr>
<tr class="memdesc:a408865b98504ee5a16776610216adacf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns an Eulerian trail of a graph </li>
</ul>
 <a href="#a408865b98504ee5a16776610216adacf">More...</a><br /></td></tr>
<tr class="separator:a408865b98504ee5a16776610216adacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8d40d943191c30a9cb94a4edccd9c8"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:aee8d40d943191c30a9cb94a4edccd9c8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#aee8d40d943191c30a9cb94a4edccd9c8">HamiltonianPath</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g)</td></tr>
<tr class="memdesc:aee8d40d943191c30a9cb94a4edccd9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns a Hamiltonian Path of a graph </li>
</ul>
 <a href="#aee8d40d943191c30a9cb94a4edccd9c8">More...</a><br /></td></tr>
<tr class="separator:aee8d40d943191c30a9cb94a4edccd9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a6cc4daa6537b9129112cf6ddd6d58"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a07a6cc4daa6537b9129112cf6ddd6d58"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a07a6cc4daa6537b9129112cf6ddd6d58">HamiltonianCycle</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g)</td></tr>
<tr class="memdesc:a07a6cc4daa6537b9129112cf6ddd6d58"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns a Hamiltonian Cycle of a graph </li>
</ul>
 <a href="#a07a6cc4daa6537b9129112cf6ddd6d58">More...</a><br /></td></tr>
<tr class="separator:a07a6cc4daa6537b9129112cf6ddd6d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f0efe9bf810e5407d59997da5921f8"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:aa9f0efe9bf810e5407d59997da5921f8"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> &gt;, std::vector&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#aa9f0efe9bf810e5407d59997da5921f8">Bipartition</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:aa9f0efe9bf810e5407d59997da5921f8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns a bipartition of Graph g, if exists, throws a std::runtime_error otherwise. </li>
</ul>
 <a href="#aa9f0efe9bf810e5407d59997da5921f8">More...</a><br /></td></tr>
<tr class="separator:aa9f0efe9bf810e5407d59997da5921f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617c0fa7ddfd873a6f87650aebbd9036"><td class="memTemplParams" colspan="2"><a class="anchor" id="a617c0fa7ddfd873a6f87650aebbd9036"></a>
template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a617c0fa7ddfd873a6f87650aebbd9036"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>, std::vector&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DijkstraPath</b> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> source)</td></tr>
<tr class="separator:a617c0fa7ddfd873a6f87650aebbd9036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984fd24e7208842bf087f0b341108b87"><td class="memTemplParams" colspan="2"><a class="anchor" id="a984fd24e7208842bf087f0b341108b87"></a>
template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a984fd24e7208842bf087f0b341108b87"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>, std::vector&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BellmanFordPath</b> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> source)</td></tr>
<tr class="separator:a984fd24e7208842bf087f0b341108b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec06e4776dfa324a2f58566954ef6ffe"><td class="memTemplParams" colspan="2"><a class="anchor" id="aec06e4776dfa324a2f58566954ef6ffe"></a>
template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:aec06e4776dfa324a2f58566954ef6ffe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgraph_1_1_a_p_s_p_state.html">APSPState</a>&lt; <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &gt;::PM&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FloydRoyWarshallPath</b> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g)</td></tr>
<tr class="separator:aec06e4776dfa324a2f58566954ef6ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0c908f754d5d6a0f4ca3c007f94287"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5f0c908f754d5d6a0f4ca3c007f94287"></a>
template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a5f0c908f754d5d6a0f4ca3c007f94287"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgraph_1_1_distance_array.html">DistanceArray</a>&lt; <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DijkstraDistance</b> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> source)</td></tr>
<tr class="separator:a5f0c908f754d5d6a0f4ca3c007f94287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be90270cd82c37b4a46ed1edb573bdb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7be90270cd82c37b4a46ed1edb573bdb"></a>
template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a7be90270cd82c37b4a46ed1edb573bdb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgraph_1_1_distance_array.html">DistanceArray</a>&lt; <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BellmanFordDistance</b> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> source)</td></tr>
<tr class="separator:a7be90270cd82c37b4a46ed1edb573bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32082f09aa861316b5da91e12ccc2b4a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a32082f09aa861316b5da91e12ccc2b4a"></a>
template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a32082f09aa861316b5da91e12ccc2b4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgraph_1_1_a_p_s_p_state.html">APSPState</a>&lt; <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &gt;::AM&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FloydRoyWarshallDistance</b> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g)</td></tr>
<tr class="separator:a32082f09aa861316b5da91e12ccc2b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5bddf71f16732a040d2abab7ca1d8e"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:acd5bddf71f16732a040d2abab7ca1d8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgraph_1_1_color_state.html">ColorState</a>&lt; <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#acd5bddf71f16732a040d2abab7ca1d8e">vertexColoring</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, std::vector&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> &gt; vertices)</td></tr>
<tr class="memdesc:acd5bddf71f16732a040d2abab7ca1d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns a map of vertex and corresponding chromatic number for a particular sequence of vertices </li>
</ul>
 <a href="#acd5bddf71f16732a040d2abab7ca1d8e">More...</a><br /></td></tr>
<tr class="separator:acd5bddf71f16732a040d2abab7ca1d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5337b96d2df3cf5fa6c6a68353fc5399"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a5337b96d2df3cf5fa6c6a68353fc5399"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgraph_1_1_color_state.html">ColorState</a>&lt; <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a5337b96d2df3cf5fa6c6a68353fc5399">minVertexColoring</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a5337b96d2df3cf5fa6c6a68353fc5399"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Determines the map of vertices and corresponding chromatic number for all possible sequence of vertices </li>
</ul>
 <a href="#a5337b96d2df3cf5fa6c6a68353fc5399">More...</a><br /></td></tr>
<tr class="separator:a5337b96d2df3cf5fa6c6a68353fc5399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a694b54f33b86d8783c64c13f5d456"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:ad0a694b54f33b86d8783c64c13f5d456"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgraph_1_1_color_state.html">ColorState</a>&lt; <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#ad0a694b54f33b86d8783c64c13f5d456">WelshPowellColoring</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:ad0a694b54f33b86d8783c64c13f5d456"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Vertex Coloring algorithm using some heuristics. Determines the map of vertices and corresponding chromatic number for all possible sequence of vertices </li>
</ul>
 <a href="#ad0a694b54f33b86d8783c64c13f5d456">More...</a><br /></td></tr>
<tr class="separator:ad0a694b54f33b86d8783c64c13f5d456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abcbd794e31cc28a3f4e8dac0b5e5c7"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a8abcbd794e31cc28a3f4e8dac0b5e5c7"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a8abcbd794e31cc28a3f4e8dac0b5e5c7">chromaticNumber</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g)</td></tr>
<tr class="memdesc:a8abcbd794e31cc28a3f4e8dac0b5e5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns the chromatic number for a graph object </li>
</ul>
 <a href="#a8abcbd794e31cc28a3f4e8dac0b5e5c7">More...</a><br /></td></tr>
<tr class="separator:a8abcbd794e31cc28a3f4e8dac0b5e5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b56ccb4b22857dd9826c748c9f2e2a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b56ccb4b22857dd9826c748c9f2e2a3"></a>
std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pair_invert</b> (int z)</td></tr>
<tr class="separator:a0b56ccb4b22857dd9826c748c9f2e2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9628a7c2c3c79cfaa931d059e42658"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a1d9628a7c2c3c79cfaa931d059e42658"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgraph_1_1_color_state.html">ColorState</a>&lt; <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>, std::pair&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a1d9628a7c2c3c79cfaa931d059e42658">minEdgeColoring</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a1d9628a7c2c3c79cfaa931d059e42658"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Determines the map of edges and corresponding chromatic number for all possible sequence of vertices </li>
</ul>
 <a href="#a1d9628a7c2c3c79cfaa931d059e42658">More...</a><br /></td></tr>
<tr class="separator:a1d9628a7c2c3c79cfaa931d059e42658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0983c36b9f41ade0ae678524e8d761"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a4b0983c36b9f41ade0ae678524e8d761"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a4b0983c36b9f41ade0ae678524e8d761">chromaticIndex</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g)</td></tr>
<tr class="memdesc:a4b0983c36b9f41ade0ae678524e8d761"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns the minimum number of colors used in Edge coloring </li>
</ul>
 <a href="#a4b0983c36b9f41ade0ae678524e8d761">More...</a><br /></td></tr>
<tr class="separator:a4b0983c36b9f41ade0ae678524e8d761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c41719547528ea22af228adcd69668f"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a5c41719547528ea22af228adcd69668f"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a5c41719547528ea22af228adcd69668f">Size</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a5c41719547528ea22af228adcd69668f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns number of edges in Graph g </li>
</ul>
 <a href="#a5c41719547528ea22af228adcd69668f">More...</a><br /></td></tr>
<tr class="separator:a5c41719547528ea22af228adcd69668f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5445f93fca1a98409fe09d12e964b0e"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:ab5445f93fca1a98409fe09d12e964b0e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#ab5445f93fca1a98409fe09d12e964b0e">outDegree</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> v)</td></tr>
<tr class="memdesc:ab5445f93fca1a98409fe09d12e964b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns the number of edges directed out of <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> v in Graph g </li>
</ul>
 <a href="#ab5445f93fca1a98409fe09d12e964b0e">More...</a><br /></td></tr>
<tr class="separator:ab5445f93fca1a98409fe09d12e964b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdba5273142484115f58a92ac442213"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a7cdba5273142484115f58a92ac442213"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a7cdba5273142484115f58a92ac442213">inDegree</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> v)</td></tr>
<tr class="memdesc:a7cdba5273142484115f58a92ac442213"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns the number of edges directed towards <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> v in Graph g </li>
</ul>
 <a href="#a7cdba5273142484115f58a92ac442213">More...</a><br /></td></tr>
<tr class="separator:a7cdba5273142484115f58a92ac442213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d26be4aeb4fae8db06762dd366a5714"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a1d26be4aeb4fae8db06762dd366a5714"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a1d26be4aeb4fae8db06762dd366a5714">degree</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> v)</td></tr>
<tr class="memdesc:a1d26be4aeb4fae8db06762dd366a5714"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns the total number of edges of <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> v in Graph g </li>
</ul>
 <a href="#a1d26be4aeb4fae8db06762dd366a5714">More...</a><br /></td></tr>
<tr class="separator:a1d26be4aeb4fae8db06762dd366a5714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d8db67ff4e058129e82fdc5a66abc0"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:ad9d8db67ff4e058129e82fdc5a66abc0"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#ad9d8db67ff4e058129e82fdc5a66abc0">nregular</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:ad9d8db67ff4e058129e82fdc5a66abc0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns the degree of each vertex in Graph g if degree of all vertex is equal, returns 0 otherwise </li>
</ul>
 <a href="#ad9d8db67ff4e058129e82fdc5a66abc0">More...</a><br /></td></tr>
<tr class="separator:ad9d8db67ff4e058129e82fdc5a66abc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239f5d9273230086f3c85e29dc861537"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a239f5d9273230086f3c85e29dc861537"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgraph_1_1_adjacency_list.html#a38fb996cc38fcb1cf20fbd601594c900">Graph::EdgeType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a239f5d9273230086f3c85e29dc861537">Radius</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a239f5d9273230086f3c85e29dc861537"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns the radius eccentricity in Graph g </li>
</ul>
 <a href="#a239f5d9273230086f3c85e29dc861537">More...</a><br /></td></tr>
<tr class="separator:a239f5d9273230086f3c85e29dc861537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4872e63b02686bd6c7c4299198e8b34d"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a4872e63b02686bd6c7c4299198e8b34d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgraph_1_1_adjacency_list.html#a38fb996cc38fcb1cf20fbd601594c900">Graph::EdgeType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a4872e63b02686bd6c7c4299198e8b34d">Diameter</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a4872e63b02686bd6c7c4299198e8b34d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns the diameter of Graph g </li>
</ul>
 <a href="#a4872e63b02686bd6c7c4299198e8b34d">More...</a><br /></td></tr>
<tr class="separator:a4872e63b02686bd6c7c4299198e8b34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16770dced352b595abf69d985dcb6c2"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:ab16770dced352b595abf69d985dcb6c2"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#ab16770dced352b595abf69d985dcb6c2">Density</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:ab16770dced352b595abf69d985dcb6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns the density of edges with respect to vertices in Graph g </li>
</ul>
 <a href="#ab16770dced352b595abf69d985dcb6c2">More...</a><br /></td></tr>
<tr class="separator:ab16770dced352b595abf69d985dcb6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef1e1be3e79a2b6990ed51b4e7c8e7b"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a7ef1e1be3e79a2b6990ed51b4e7c8e7b"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a7ef1e1be3e79a2b6990ed51b4e7c8e7b">noOfComponents</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g)</td></tr>
<tr class="memdesc:a7ef1e1be3e79a2b6990ed51b4e7c8e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns the number of connected components of a graph </li>
</ul>
 <a href="#a7ef1e1be3e79a2b6990ed51b4e7c8e7b">More...</a><br /></td></tr>
<tr class="separator:a7ef1e1be3e79a2b6990ed51b4e7c8e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa224936c832e32ae7249027f33d0110"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaa224936c832e32ae7249027f33d0110"></a>
template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:aaa224936c832e32ae7249027f33d0110"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>KruskalMinimumSpan</b> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g)</td></tr>
<tr class="separator:aaa224936c832e32ae7249027f33d0110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f345b5912e9b8168237438eb66b81c"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa1f345b5912e9b8168237438eb66b81c"></a>
template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:aa1f345b5912e9b8168237438eb66b81c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PrimMinimumSpan</b> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g)</td></tr>
<tr class="separator:aa1f345b5912e9b8168237438eb66b81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c255f9ddace34e75acdadef33487e26"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9c255f9ddace34e75acdadef33487e26"></a>
template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a9c255f9ddace34e75acdadef33487e26"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BoruvkaMinimumSpan</b> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g)</td></tr>
<tr class="separator:a9c255f9ddace34e75acdadef33487e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f5e9de42cb2e5653ecadd4b16e19b8"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename F &gt; </td></tr>
<tr class="memitem:aa7f5e9de42cb2e5653ecadd4b16e19b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgraph_1_1_m_s_t_state.html">MSTState</a>&lt; <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#aa7f5e9de42cb2e5653ecadd4b16e19b8">Kruskal</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g, F callback)</td></tr>
<tr class="memdesc:aa7f5e9de42cb2e5653ecadd4b16e19b8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns the Minimum Cost Spanning tree obtained using Kruskal's ALgorithm </li>
</ul>
 <a href="#aa7f5e9de42cb2e5653ecadd4b16e19b8">More...</a><br /></td></tr>
<tr class="separator:aa7f5e9de42cb2e5653ecadd4b16e19b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704fced132ca5e0e5ea7f7c9ba073a10"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a704fced132ca5e0e5ea7f7c9ba073a10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgraph_1_1_m_s_t_state.html">MSTState</a>&lt; <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a704fced132ca5e0e5ea7f7c9ba073a10">Boruvka</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g)</td></tr>
<tr class="memdesc:a704fced132ca5e0e5ea7f7c9ba073a10"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns the Minimum Cost Spanning tree obtained using Boruvka ALgorithm </li>
</ul>
 <a href="#a704fced132ca5e0e5ea7f7c9ba073a10">More...</a><br /></td></tr>
<tr class="separator:a704fced132ca5e0e5ea7f7c9ba073a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537e5324e67e666e68331c22a482da23"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a537e5324e67e666e68331c22a482da23"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgraph_1_1_m_s_t_state.html">MSTState</a>&lt; <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a537e5324e67e666e68331c22a482da23">Prim</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a537e5324e67e666e68331c22a482da23"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns the Minimum Cost Spanning tree obtained using Prim's ALgorithm </li>
</ul>
 <a href="#a537e5324e67e666e68331c22a482da23">More...</a><br /></td></tr>
<tr class="separator:a537e5324e67e666e68331c22a482da23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ec4176d88500a4a129ac2a3361a9ee"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a27ec4176d88500a4a129ac2a3361a9ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a27ec4176d88500a4a129ac2a3361a9ee">Union</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g1, <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g2)</td></tr>
<tr class="memdesc:a27ec4176d88500a4a129ac2a3361a9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns union of two Graph datastructures </li>
</ul>
 <a href="#a27ec4176d88500a4a129ac2a3361a9ee">More...</a><br /></td></tr>
<tr class="separator:a27ec4176d88500a4a129ac2a3361a9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af6c970655d50a0bd498d4d20b4519a"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a9af6c970655d50a0bd498d4d20b4519a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a9af6c970655d50a0bd498d4d20b4519a">intersection</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g1, <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g2)</td></tr>
<tr class="memdesc:a9af6c970655d50a0bd498d4d20b4519a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns intersection of two Graph datastructures </li>
</ul>
 <a href="#a9af6c970655d50a0bd498d4d20b4519a">More...</a><br /></td></tr>
<tr class="separator:a9af6c970655d50a0bd498d4d20b4519a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d32f8690fbd7a81934e9e434c848ae"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a18d32f8690fbd7a81934e9e434c848ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a18d32f8690fbd7a81934e9e434c848ae">join</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g1, <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g2)</td></tr>
<tr class="memdesc:a18d32f8690fbd7a81934e9e434c848ae"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns natural join of two Graph datastructures </li>
</ul>
 <a href="#a18d32f8690fbd7a81934e9e434c848ae">More...</a><br /></td></tr>
<tr class="separator:a18d32f8690fbd7a81934e9e434c848ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cf30b107915cae80906b4fcda2e5b2"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a80cf30b107915cae80906b4fcda2e5b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a80cf30b107915cae80906b4fcda2e5b2">symmetric_difference</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g1, <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g2)</td></tr>
<tr class="memdesc:a80cf30b107915cae80906b4fcda2e5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns symmetric_difference of two Graph datastructures </li>
</ul>
 <a href="#a80cf30b107915cae80906b4fcda2e5b2">More...</a><br /></td></tr>
<tr class="separator:a80cf30b107915cae80906b4fcda2e5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2513261fe79cfc0abee1fe4274737a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraph.html#af2513261fe79cfc0abee1fe4274737a6">pairCompute</a> (int x, int y)</td></tr>
<tr class="memdesc:af2513261fe79cfc0abee1fe4274737a6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>returns the result of function (x+y) *(x+y+1) / 2 +y </li>
</ul>
 <a href="#af2513261fe79cfc0abee1fe4274737a6">More...</a><br /></td></tr>
<tr class="separator:af2513261fe79cfc0abee1fe4274737a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857d0b99072fbb221fb4098e43ae3ea4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a857d0b99072fbb221fb4098e43ae3ea4">pairInvert</a> (int z)</td></tr>
<tr class="memdesc:a857d0b99072fbb221fb4098e43ae3ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>returns a pair (square root of(8*z+1)-1)/2 - y and z - (w*w+w)/2 </li>
</ul>
 <a href="#a857d0b99072fbb221fb4098e43ae3ea4">More...</a><br /></td></tr>
<tr class="separator:a857d0b99072fbb221fb4098e43ae3ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbf62eb3deeadedf7afad6aa20f2ad8"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a1dbf62eb3deeadedf7afad6aa20f2ad8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a1dbf62eb3deeadedf7afad6aa20f2ad8">cartesian_product</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g1, <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g2)</td></tr>
<tr class="memdesc:a1dbf62eb3deeadedf7afad6aa20f2ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns cartesian_product of two Graph datastructures </li>
</ul>
 <a href="#a1dbf62eb3deeadedf7afad6aa20f2ad8">More...</a><br /></td></tr>
<tr class="separator:a1dbf62eb3deeadedf7afad6aa20f2ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8420fe6320e54097c66e96c541c3b9"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:aae8420fe6320e54097c66e96c541c3b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#aae8420fe6320e54097c66e96c541c3b9">complement</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g1)</td></tr>
<tr class="memdesc:aae8420fe6320e54097c66e96c541c3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns complement of a Graph datastructure </li>
</ul>
 <a href="#aae8420fe6320e54097c66e96c541c3b9">More...</a><br /></td></tr>
<tr class="separator:aae8420fe6320e54097c66e96c541c3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9a579f0470be3495792b40b18c30c2"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:aeb9a579f0470be3495792b40b18c30c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#aeb9a579f0470be3495792b40b18c30c2">EdgeDeletionSubgraph</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g1, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> x, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> y)</td></tr>
<tr class="memdesc:aeb9a579f0470be3495792b40b18c30c2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns the graph after deleting the edge between vertex x and vertex y of graph g1 </li>
</ul>
 <a href="#aeb9a579f0470be3495792b40b18c30c2">More...</a><br /></td></tr>
<tr class="separator:aeb9a579f0470be3495792b40b18c30c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239b80d07aa07ae2eadbbb9731f40b43"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a239b80d07aa07ae2eadbbb9731f40b43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a239b80d07aa07ae2eadbbb9731f40b43">VertexDeletionSubgraph</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g1, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> x)</td></tr>
<tr class="memdesc:a239b80d07aa07ae2eadbbb9731f40b43"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns the graph after deleting the vertex x of graph g1 </li>
</ul>
 <a href="#a239b80d07aa07ae2eadbbb9731f40b43">More...</a><br /></td></tr>
<tr class="separator:a239b80d07aa07ae2eadbbb9731f40b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c6526885c3c807dd6f2e6aef5c6109"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a11c6526885c3c807dd6f2e6aef5c6109"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a11c6526885c3c807dd6f2e6aef5c6109">EdgeContractionMinor</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> x, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> y)</td></tr>
<tr class="memdesc:a11c6526885c3c807dd6f2e6aef5c6109"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns the graph minor after contracting the edge (x,y) of graph g </li>
</ul>
 <a href="#a11c6526885c3c807dd6f2e6aef5c6109">More...</a><br /></td></tr>
<tr class="separator:a11c6526885c3c807dd6f2e6aef5c6109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bce75612817a0cd0e1349602b4fe1e"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:af8bce75612817a0cd0e1349602b4fe1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#af8bce75612817a0cd0e1349602b4fe1e">line</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g)</td></tr>
<tr class="memdesc:af8bce75612817a0cd0e1349602b4fe1e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns line graph of a Graph datastructure </li>
</ul>
 <a href="#af8bce75612817a0cd0e1349602b4fe1e">More...</a><br /></td></tr>
<tr class="separator:af8bce75612817a0cd0e1349602b4fe1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12aadb2b88db64b116fcf922c161e784"><td class="memTemplParams" colspan="2"><a class="anchor" id="a12aadb2b88db64b116fcf922c161e784"></a>
template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a12aadb2b88db64b116fcf922c161e784"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>KruskalMST</b> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g)</td></tr>
<tr class="separator:a12aadb2b88db64b116fcf922c161e784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd0bab73f59ad173e99980a987eba27"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6dd0bab73f59ad173e99980a987eba27"></a>
template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a6dd0bab73f59ad173e99980a987eba27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PrimMST</b> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g)</td></tr>
<tr class="separator:a6dd0bab73f59ad173e99980a987eba27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9216b9af1ca9185b5747019393bf8a7a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9216b9af1ca9185b5747019393bf8a7a"></a>
template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a9216b9af1ca9185b5747019393bf8a7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BoruvkaMST</b> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g)</td></tr>
<tr class="separator:a9216b9af1ca9185b5747019393bf8a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94693eb5b7a9ba65b1da69d8ecde02b"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:ac94693eb5b7a9ba65b1da69d8ecde02b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#ac94693eb5b7a9ba65b1da69d8ecde02b">isVertex</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> x)</td></tr>
<tr class="memdesc:ac94693eb5b7a9ba65b1da69d8ecde02b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> x is a vertex of Graph g, false otherwise </li>
</ul>
 <a href="#ac94693eb5b7a9ba65b1da69d8ecde02b">More...</a><br /></td></tr>
<tr class="separator:ac94693eb5b7a9ba65b1da69d8ecde02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e003e6fc1c423c859fc0a98cc34a2c0"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a9e003e6fc1c423c859fc0a98cc34a2c0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> x, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> y)</td></tr>
<tr class="memdesc:a9e003e6fc1c423c859fc0a98cc34a2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> x and <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> y are adjacent in Graph g, false otherwise </li>
</ul>
 <a href="#a9e003e6fc1c423c859fc0a98cc34a2c0">More...</a><br /></td></tr>
<tr class="separator:a9e003e6fc1c423c859fc0a98cc34a2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f38bde9b380bda9aaaab4413d7e5d1"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a87f38bde9b380bda9aaaab4413d7e5d1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a87f38bde9b380bda9aaaab4413d7e5d1">isSubgraph</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;h)</td></tr>
<tr class="memdesc:a87f38bde9b380bda9aaaab4413d7e5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if Graph g is a subgraph of Graph h, false otherwise </li>
</ul>
 <a href="#a87f38bde9b380bda9aaaab4413d7e5d1">More...</a><br /></td></tr>
<tr class="separator:a87f38bde9b380bda9aaaab4413d7e5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afd196b78ff4dfdfabba1d35303f01f"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a1afd196b78ff4dfdfabba1d35303f01f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a1afd196b78ff4dfdfabba1d35303f01f">isSpanningSubgraph</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;h)</td></tr>
<tr class="memdesc:a1afd196b78ff4dfdfabba1d35303f01f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if Graph g is a spanning subgraph of Graph h, false otherwise </li>
</ul>
 <a href="#a1afd196b78ff4dfdfabba1d35303f01f">More...</a><br /></td></tr>
<tr class="separator:a1afd196b78ff4dfdfabba1d35303f01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce45abbccf3454e0be31b98aaa4db6a"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a7ce45abbccf3454e0be31b98aaa4db6a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a7ce45abbccf3454e0be31b98aaa4db6a">isConnected</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a7ce45abbccf3454e0be31b98aaa4db6a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if all vertices of Graph g can be traversed, false otherwise </li>
</ul>
 <a href="#a7ce45abbccf3454e0be31b98aaa4db6a">More...</a><br /></td></tr>
<tr class="separator:a7ce45abbccf3454e0be31b98aaa4db6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872940ce015a9f1d8c6900c76a1532e7"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a872940ce015a9f1d8c6900c76a1532e7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a872940ce015a9f1d8c6900c76a1532e7">isConnected</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> x, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> y)</td></tr>
<tr class="memdesc:a872940ce015a9f1d8c6900c76a1532e7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> y can be reached from <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> x in Graph g, false otherwise </li>
</ul>
 <a href="#a872940ce015a9f1d8c6900c76a1532e7">More...</a><br /></td></tr>
<tr class="separator:a872940ce015a9f1d8c6900c76a1532e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978e407919e226890fdb46d72866ef04"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a978e407919e226890fdb46d72866ef04"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a978e407919e226890fdb46d72866ef04">isBipartite</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a978e407919e226890fdb46d72866ef04"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if Graph g is bipartite, false otherwise </li>
</ul>
 <a href="#a978e407919e226890fdb46d72866ef04">More...</a><br /></td></tr>
<tr class="separator:a978e407919e226890fdb46d72866ef04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273935d9afa64a48f4e1879195b6ddec"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a273935d9afa64a48f4e1879195b6ddec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a273935d9afa64a48f4e1879195b6ddec">isComponent</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g1, <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g2)</td></tr>
<tr class="memdesc:a273935d9afa64a48f4e1879195b6ddec"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if Graph g1 is a component of Graph g2, false otherwise </li>
</ul>
 <a href="#a273935d9afa64a48f4e1879195b6ddec">More...</a><br /></td></tr>
<tr class="separator:a273935d9afa64a48f4e1879195b6ddec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6db7031876867ba5a173dd9828f7fb"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:ace6db7031876867ba5a173dd9828f7fb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#ace6db7031876867ba5a173dd9828f7fb">isRegular</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:ace6db7031876867ba5a173dd9828f7fb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if degree of all vertices in Graph g is equal, false otherwise </li>
</ul>
 <a href="#ace6db7031876867ba5a173dd9828f7fb">More...</a><br /></td></tr>
<tr class="separator:ace6db7031876867ba5a173dd9828f7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87376811d5603b78059b9def7f026e03"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a87376811d5603b78059b9def7f026e03"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a87376811d5603b78059b9def7f026e03">isEulerian</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a87376811d5603b78059b9def7f026e03"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if degree of all vertices in Graph g is even and Graph g is connected, false otherwise </li>
</ul>
 <a href="#a87376811d5603b78059b9def7f026e03">More...</a><br /></td></tr>
<tr class="separator:a87376811d5603b78059b9def7f026e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7885ff6225a44cb3132023197cbafa8"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:ab7885ff6225a44cb3132023197cbafa8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#ab7885ff6225a44cb3132023197cbafa8">isSemiEulerian</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:ab7885ff6225a44cb3132023197cbafa8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if degree of exactly two vertices in Graph g is even and Graph g is connected, false otherwise </li>
</ul>
 <a href="#ab7885ff6225a44cb3132023197cbafa8">More...</a><br /></td></tr>
<tr class="separator:ab7885ff6225a44cb3132023197cbafa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6e15c7fd1c835e1ea1b9c518945371"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a3d6e15c7fd1c835e1ea1b9c518945371"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a3d6e15c7fd1c835e1ea1b9c518945371">isHamiltonian</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g)</td></tr>
<tr class="memdesc:a3d6e15c7fd1c835e1ea1b9c518945371"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if the graph is Hamiltoian, false other wise </li>
</ul>
 <a href="#a3d6e15c7fd1c835e1ea1b9c518945371">More...</a><br /></td></tr>
<tr class="separator:a3d6e15c7fd1c835e1ea1b9c518945371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ac00d84e69840a1b8311235177010c"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a66ac00d84e69840a1b8311235177010c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a66ac00d84e69840a1b8311235177010c">isSemiHamiltonian</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g)</td></tr>
<tr class="memdesc:a66ac00d84e69840a1b8311235177010c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if the graph is Semi-Hamiltoian, false other wise </li>
</ul>
 <a href="#a66ac00d84e69840a1b8311235177010c">More...</a><br /></td></tr>
<tr class="separator:a66ac00d84e69840a1b8311235177010c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013ebe74e89fec9fd096c9bdfe4bb162"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a013ebe74e89fec9fd096c9bdfe4bb162"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a013ebe74e89fec9fd096c9bdfe4bb162">isHypoHamiltonian</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> g)</td></tr>
<tr class="memdesc:a013ebe74e89fec9fd096c9bdfe4bb162"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if the graph is Hypo Hamiltoian, false other wise </li>
</ul>
 <a href="#a013ebe74e89fec9fd096c9bdfe4bb162">More...</a><br /></td></tr>
<tr class="separator:a013ebe74e89fec9fd096c9bdfe4bb162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac12e0ca7f5cb7c38f5e27fb7b2b0c4"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a1ac12e0ca7f5cb7c38f5e27fb7b2b0c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a1ac12e0ca7f5cb7c38f5e27fb7b2b0c4">isComplete</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a1ac12e0ca7f5cb7c38f5e27fb7b2b0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if atleast one edge is present between all combination of vertices (except self loops) in Graph g, false otherwise </li>
</ul>
 <a href="#a1ac12e0ca7f5cb7c38f5e27fb7b2b0c4">More...</a><br /></td></tr>
<tr class="separator:a1ac12e0ca7f5cb7c38f5e27fb7b2b0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bd95d92a70961e82d3751b1eb2918a"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a94bd95d92a70961e82d3751b1eb2918a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a94bd95d92a70961e82d3751b1eb2918a">isComplement</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;h)</td></tr>
<tr class="memdesc:a94bd95d92a70961e82d3751b1eb2918a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if edges present in Graph g are not present in Graph h and vice versa (neglecting self loops), false otherwise </li>
</ul>
 <a href="#a94bd95d92a70961e82d3751b1eb2918a">More...</a><br /></td></tr>
<tr class="separator:a94bd95d92a70961e82d3751b1eb2918a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c937901146559ee61bfad0879cca51"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:af9c937901146559ee61bfad0879cca51"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#af9c937901146559ee61bfad0879cca51">isEdgeless</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:af9c937901146559ee61bfad0879cca51"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if there are no edges in Graph g, false otherwise </li>
</ul>
 <a href="#af9c937901146559ee61bfad0879cca51">More...</a><br /></td></tr>
<tr class="separator:af9c937901146559ee61bfad0879cca51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36dc23681dd3e0fb72cad8a1c803d75"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:ae36dc23681dd3e0fb72cad8a1c803d75"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#ae36dc23681dd3e0fb72cad8a1c803d75">isCyclic</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:ae36dc23681dd3e0fb72cad8a1c803d75"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if there is atleast one path starting and ending at the same vertex in Graph g, false otherwise </li>
</ul>
 <a href="#ae36dc23681dd3e0fb72cad8a1c803d75">More...</a><br /></td></tr>
<tr class="separator:ae36dc23681dd3e0fb72cad8a1c803d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b26f07c06de8b3ab3249efc3756afab"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a3b26f07c06de8b3ab3249efc3756afab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a3b26f07c06de8b3ab3249efc3756afab">isCentre</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> x)</td></tr>
<tr class="memdesc:a3b26f07c06de8b3ab3249efc3756afab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> x is at the centre of Graph g, false otherwise </li>
</ul>
 <a href="#a3b26f07c06de8b3ab3249efc3756afab">More...</a><br /></td></tr>
<tr class="separator:a3b26f07c06de8b3ab3249efc3756afab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b63f2ad24994baeb1f6235e2ae7c73"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a83b63f2ad24994baeb1f6235e2ae7c73"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a83b63f2ad24994baeb1f6235e2ae7c73">isPeriphery</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> x)</td></tr>
<tr class="memdesc:a83b63f2ad24994baeb1f6235e2ae7c73"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> x lies at the periphery of Graph g, false otherwise </li>
</ul>
 <a href="#a83b63f2ad24994baeb1f6235e2ae7c73">More...</a><br /></td></tr>
<tr class="separator:a83b63f2ad24994baeb1f6235e2ae7c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df7a3b7971d7f1f2f51aabb43d9aa26"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a0df7a3b7971d7f1f2f51aabb43d9aa26"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a0df7a3b7971d7f1f2f51aabb43d9aa26">isEmpty</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a0df7a3b7971d7f1f2f51aabb43d9aa26"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if there are no vertex in Graph g, false otherwise </li>
</ul>
 <a href="#a0df7a3b7971d7f1f2f51aabb43d9aa26">More...</a><br /></td></tr>
<tr class="separator:a0df7a3b7971d7f1f2f51aabb43d9aa26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1033a999aa291d80628b2d6dc0ea0911"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a1033a999aa291d80628b2d6dc0ea0911"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a1033a999aa291d80628b2d6dc0ea0911">isSparse</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a1033a999aa291d80628b2d6dc0ea0911"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if number of edges in Graph g is less than or equal to twice the number of vertices in graph g, false otherwise </li>
</ul>
 <a href="#a1033a999aa291d80628b2d6dc0ea0911">More...</a><br /></td></tr>
<tr class="separator:a1033a999aa291d80628b2d6dc0ea0911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881b9e13435114913b8a76518ac081dc"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a881b9e13435114913b8a76518ac081dc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a881b9e13435114913b8a76518ac081dc">isTree</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a881b9e13435114913b8a76518ac081dc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Returns true if Graph g is a tree, false otherwise </li>
</ul>
 <a href="#a881b9e13435114913b8a76518ac081dc">More...</a><br /></td></tr>
<tr class="separator:a881b9e13435114913b8a76518ac081dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d48b42a50e719da807f9645f6c80864"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a3d48b42a50e719da807f9645f6c80864"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgraph_1_1_s_s_s_p_state.html">SSSPState</a>&lt; <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a3d48b42a50e719da807f9645f6c80864">Djikstra</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> s)</td></tr>
<tr class="memdesc:a3d48b42a50e719da807f9645f6c80864"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Applies Djikstra's Algorithm on a grpah object </li>
</ul>
 <a href="#a3d48b42a50e719da807f9645f6c80864">More...</a><br /></td></tr>
<tr class="separator:a3d48b42a50e719da807f9645f6c80864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19041caec49d493e6335222b16a271ee"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a19041caec49d493e6335222b16a271ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgraph_1_1_s_s_s_p_state.html">SSSPState</a>&lt; <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a19041caec49d493e6335222b16a271ee">BellmanFord</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> s)</td></tr>
<tr class="memdesc:a19041caec49d493e6335222b16a271ee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Applies Bellman-Ford Algorithm on a graph object </li>
</ul>
 <a href="#a19041caec49d493e6335222b16a271ee">More...</a><br /></td></tr>
<tr class="separator:a19041caec49d493e6335222b16a271ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bd1ad1642caf6576aa982733ee58f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84bd1ad1642caf6576aa982733ee58f7"></a>
<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&lt; std::string, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>makeGraph</b> (std::istream &amp;in)</td></tr>
<tr class="separator:a84bd1ad1642caf6576aa982733ee58f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350c47b015d86eb18355a6f56dd80656"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a350c47b015d86eb18355a6f56dd80656"></a>
<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&lt; std::string, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>makeGraph</b> (std::string filename)</td></tr>
<tr class="separator:a350c47b015d86eb18355a6f56dd80656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4c54f3801feaa1914ad866b9f92b4a"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:aeb4c54f3801feaa1914ad866b9f92b4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#aeb4c54f3801feaa1914ad866b9f92b4a">displayGraph</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, std::ostream &amp;out=std::cout)</td></tr>
<tr class="memdesc:aeb4c54f3801feaa1914ad866b9f92b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Function to display adjacency list of a graph </li>
</ul>
 <a href="#aeb4c54f3801feaa1914ad866b9f92b4a">More...</a><br /></td></tr>
<tr class="separator:aeb4c54f3801feaa1914ad866b9f92b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d92d85af1625f0f8c7f4845a8a3b6a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a91d92d85af1625f0f8c7f4845a8a3b6a"></a>
template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a91d92d85af1625f0f8c7f4845a8a3b6a"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>writeGraph</b> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="separator:a91d92d85af1625f0f8c7f4845a8a3b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bdad6e57791dad49cd324725a6da54"><td class="memTemplParams" colspan="2"><a class="anchor" id="a54bdad6e57791dad49cd324725a6da54"></a>
template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a54bdad6e57791dad49cd324725a6da54"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>writeGraphDOT</b> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g)</td></tr>
<tr class="separator:a54bdad6e57791dad49cd324725a6da54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12612233d1f03f2593419ab879be2d91"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename F &gt; </td></tr>
<tr class="memitem:a12612233d1f03f2593419ab879be2d91"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a12612233d1f03f2593419ab879be2d91">VisitVertices</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, F f)</td></tr>
<tr class="memdesc:a12612233d1f03f2593419ab879be2d91"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>function to visit all vertices of a graph </li>
</ul>
 <a href="#a12612233d1f03f2593419ab879be2d91">More...</a><br /></td></tr>
<tr class="separator:a12612233d1f03f2593419ab879be2d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb243df0343a7f117a0de2817792de58"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename F &gt; </td></tr>
<tr class="memitem:acb243df0343a7f117a0de2817792de58"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#acb243df0343a7f117a0de2817792de58">VisitNeighbours</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> v, F f)</td></tr>
<tr class="memdesc:acb243df0343a7f117a0de2817792de58"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>function to visit all neighbours of a vertex of a graph </li>
</ul>
 <a href="#acb243df0343a7f117a0de2817792de58">More...</a><br /></td></tr>
<tr class="separator:acb243df0343a7f117a0de2817792de58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee632989a4fe4010b653e350d54afc7"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename F &gt; </td></tr>
<tr class="memitem:a0ee632989a4fe4010b653e350d54afc7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraph.html#a0ee632989a4fe4010b653e350d54afc7">VisitEdges</a> (<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;g, F f)</td></tr>
<tr class="memdesc:a0ee632989a4fe4010b653e350d54afc7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>function to visit all edges of a graph </li>
</ul>
 <a href="#a0ee632989a4fe4010b653e350d54afc7">More...</a><br /></td></tr>
<tr class="separator:a0ee632989a4fe4010b653e350d54afc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="apsp_8hpp_source.html">apsp.hpp</a> - Header file that has collection of all pair shortest path finding algorithms </p>
<p><a class="el" href="visitors_8hpp_source.html">visitors.hpp</a> - Header file to store different traversal techniques</p>
<ul>
<li><a class="el" href="io_8hpp_source.html">io.hpp</a> - Header file that contains all input output operations</li>
<li><a class="el" href="stack_8hpp_source.html">stack.hpp</a> - header file to implement stack datastructure</li>
<li><a class="el" href="queue_8hpp_source.html">queue.hpp</a> - Header file that has a collection of all queue related datastructures</li>
<li><a class="el" href="parent_8hpp_source.html">parent.hpp</a> - header file containing structure to hold paths of vertices of a graph</li>
</ul>
<p><a class="el" href="distance_8hpp_source.html">distance.hpp</a> - Header file containing structure to hold distance of vertices of a graph</p>
<p><a class="el" href="disjointset_8hpp_source.html">disjointset.hpp</a> -Header that contains disjointset structure</p>
<p><a class="el" href="attribute_8hpp_source.html">attribute.hpp</a> - Header file to store different attributes of a graph</p>
<p><a class="el" href="edge__traits_8hpp_source.html">edge_traits.hpp</a> - Header file to store edge traits</p>
<p><a class="el" href="adjlist_8hpp_source.html">adjlist.hpp</a> - Header file that contains adjacency list of a graph</p>
<p><a class="el" href="graph_8hpp_source.html">graph.hpp</a> - Basic Header FIle for graph implementation</p>
<p><a class="el" href="sssp_8hpp_source.html">sssp.hpp</a> - Header file that has collection of single source shortest path finding algorithms.</p>
<p>seacrh.hpp - Contains execution of different searching algorithms with and without using Callback Funtions.</p>
<p><a class="el" href="predicates_8hpp_source.html">predicates.hpp</a> - Header file that has collection of boolean functions on a graph object. All these checks must evaluate to true or false.</p>
<p><a class="el" href="operations_8hpp_source.html">operations.hpp</a> - Header file that has collection of operations possible on any graph datastruture</p>
<p><a class="el" href="mst_8hpp_source.html">mst.hpp</a> - Header file that contains collectin of all Minimum Cost Spanning Tree finding algorithms</p>
<p><a class="el" href="enumeration_8hpp_source.html">enumeration.hpp</a> - Header file that has collection of functions that can enumerate different aspects of a grah object</p>
<p><a class="el" href="coloring_8hpp_source.html">coloring.hpp</a> - Header file containing collection of graph coloring algorithms.</p>
<p>collection.hpp - Header file that has functions that returns sequences and lists of different aspects of a graph object</p>
<p>The All-Pairs Shortest Path problem finds the shortest paths between every pair of vertices v, v' in the graph. Reference Link - <a href="http://en.wikipedia.org/wiki/Shortest_path_problem#All-pairs_shortest_paths">APSP</a></p>
<p>A spanning tree is a subgraph of a graph, which is a tree and connects all the vertices of the graph. A Minimum Cost Spanning Tree is a spanning tree with cost or weight less than all other spanning trees. There might be multiple Minimum Cost Spanning Trees for a graph. Each algorithm might return different Minimum Cost Spanning Tree. Reference Lin - <a href="http://en.wikipedia.org/wiki/Minimum_spanning_tree">MST</a></p>
<p>Note: Use std::bind on these predicates and a Graph object for these to be applicable to STL algorithms.</p>
<p>In computer science, graph search is the problem of visiting all the nodes in a graph in a particular manner, updating and/or checking their values along the way. Refernce Link - <a href="http://en.wikipedia.org/wiki/Graph_traversal">Graph Search</a></p>
<p>The single-source shortest-paths problem refers to, given a graph G , finding a shortest path from a given source vertex s to every vertex x. Reference Link - <a href="http://en.wikipedia.org/wiki/Shortest_path_problem#Single-source_shortest_paths">SSSP</a> </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a4e4abf0b1a5f973af70d500d9ad0d5c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegraph.html#a4e4abf0b1a5f973af70d500d9ad0d5c4">graph::DepthFirstSearch</a> = typedef <a class="el" href="classgraph_1_1_search.html">Search</a>&lt;G,<a class="el" href="classgraph_1_1_stack.html">Stack</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>To implement Depth First <a class="el" href="classgraph_1_1_search.html" title="The basic framework to implement Graph Search ">Search</a> </li>
</ul>
</p>
<p>Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. One starts at the root (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along each branch before backtracking. Refernce Link - <a href="http://en.wikipedia.org/wiki/Depth-first_search">DFS</a> </p>

<p>Definition at line <a class="el" href="search_8hpp_source.html#l00161">161</a> of file <a class="el" href="search_8hpp_source.html">search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a37427190269c66c2c77002f344418399"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegraph.html#a37427190269c66c2c77002f344418399">graph::UniformCostSearch</a> = typedef <a class="el" href="classgraph_1_1_search.html">Search</a>&lt;G,<a class="el" href="classgraph_1_1_priority_queue.html">PriorityQueue</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>To implement Uniform Cost <a class="el" href="classgraph_1_1_search.html" title="The basic framework to implement Graph Search ">Search</a> </li>
</ul>
</p>
<p>Uniform cost search is a tree search algorithm related to breadth-first search. Whereas breadth-first search determines a path to the goal state that has the least number of edges, uniform cost search determines a path to the goal state that has the lowest weight. Refernce Link - <a href="http://math.wikia.com/wiki/Uniform_cost_search">UCS</a> </p>

<p>Definition at line <a class="el" href="search_8hpp_source.html#l00151">151</a> of file <a class="el" href="search_8hpp_source.html">search.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a3f650908c1e8e62e32c991cf454682ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::pair&lt;typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>,typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&gt;,typename <a class="el" href="classgraph_1_1_adjacency_list.html#a38fb996cc38fcb1cf20fbd601594c900">Graph::EdgeType</a>&gt; graph::AdjacencyMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns adjacency matrix of Graph g </li>
</ul>
</p>
<p>The matrix is a mapping between the pair of vertices and the edge between these two vertices</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>map&lt;std::pair&lt;typename Graph::VertexType,typename Graph::VertexType&gt;,typename <a class="el" href="classgraph_1_1_adjacency_list.html#a38fb996cc38fcb1cf20fbd601594c900" title="Edge. ">Graph::EdgeType</a>&gt; m - variable to store the adjacency matrix </dd></dl>

<p>Definition at line <a class="el" href="collections_8hpp_source.html#l00267">267</a> of file <a class="el" href="collections_8hpp_source.html">collections.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    {</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        std::map&lt;std::pair&lt;typename Graph::VertexType,typename Graph::VertexType&gt;,<span class="keyword">typename</span> Graph::EdgeType&gt; m;</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g.begin();i!=g.end();++i)</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> j=g.nbegin(i-&gt;first);j!=g.nend(i-&gt;first);++j)</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;                m[std::make_pair(i-&gt;first,j-&gt;first)]=j-&gt;second;</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;        <span class="keywordflow">return</span> m;</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a19041caec49d493e6335222b16a271ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraph_1_1_s_s_s_p_state.html">SSSPState</a>&lt;<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&gt; graph::BellmanFord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Applies Bellman-Ford Algorithm on a graph object </li>
</ul>
</p>
<p>Bellman-Ford Algorithm findest the shortest path to all vertices from a single source vertex. This function returns the distance array and path array after applying Bellman-Ford Algorithm for a single source vertex.</p><ul>
<li>Reference Link - <a href="http://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm">Bellman-Ford Algorithm</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - First Parameter, a graph object on which Djikstra's Algorithm is applied</td></tr>
    <tr><td class="paramname">typename</td><td><a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> s - Second Parameter, a vertex of graph g and the source for Djikstra's algorithm</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SSSPState&lt;Graph&gt; state - Contains the modified parent array and distance array after applying Bellman-Ford Algorithm </dd></dl>

<p>Definition at line <a class="el" href="sssp_8hpp_source.html#l00136">136</a> of file <a class="el" href="sssp_8hpp_source.html">sssp.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    {</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> Graph::VertexType V;</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        SSSPState&lt;Graph&gt; state(g,s);</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt; g.order()-1; ++i)</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        {</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;            <a class="code" href="namespacegraph.html#a0ee632989a4fe4010b653e350d54afc7">VisitEdges</a>(g,std::bind(&amp;SSSPState&lt;Graph&gt;::relax, &amp;state, _1,_2));</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        }</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;        <span class="keywordflow">return</span> state;</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a0ee632989a4fe4010b653e350d54afc7"><div class="ttname"><a href="namespacegraph.html#a0ee632989a4fe4010b653e350d54afc7">graph::VisitEdges</a></div><div class="ttdeci">void VisitEdges(Graph &amp;g, F f)</div><div class="ttdoc">function to visit all edges of a graph </div><div class="ttdef"><b>Definition:</b> <a href="visitors_8hpp_source.html#l00049">visitors.hpp:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa9f0efe9bf810e5407d59997da5921f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&gt;, std::vector&lt;typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&gt; &gt; graph::Bipartition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns a bipartition of Graph g, if exists, throws a std::runtime_error otherwise. </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph&amp;</td><td>g - Parameter, a graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;std::vector&lt;typename Graph::VertexType&gt;, std::vector&lt;typename Graph::VertexType&gt;&gt; result - variable to store the pair of vectors of vertices where each vector is partition. </dd></dl>

<p>Definition at line <a class="el" href="collections_8hpp_source.html#l00543">543</a> of file <a class="el" href="collections_8hpp_source.html">collections.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;    {</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;        std::pair&lt;std::vector&lt;typename Graph::VertexType&gt;, std::vector&lt;typename Graph::VertexType&gt;&gt; result;</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;        BreadthFirstSearch&lt;Graph&gt; bfs(g,g.begin()-&gt;first);</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;        <span class="keywordtype">bool</span> flag = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;        std::map&lt;typename Graph::VertexType, int&gt; label;</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;        label[g.begin()-&gt;first] = 1;</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;        bfs.setp4([&amp;label](<span class="keyword">const</span> <span class="keyword">typename</span> Graph::VertexType&amp; x, <span class="keyword">const</span> <span class="keyword">typename</span> Graph::VertexType&amp; y)</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;        {</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;            label[y] = -label[x];</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;        });</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;        bfs.setp3([&amp;flag,&amp;label](<span class="keyword">const</span> <span class="keyword">typename</span> Graph::VertexType&amp; x, <span class="keyword">const</span> <span class="keyword">typename</span> Graph::VertexType&amp; y)</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;        {</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;            <span class="keywordflow">if</span>(label[x] == label[y])</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;            {</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;                flag = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;            }</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;        });</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;        bfs();</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;        <span class="keywordflow">if</span>(flag == <span class="keyword">false</span>)</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Graph not bipartite&quot;</span>);</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;        {</div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g.begin();i!=g.end();++i)</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;                <span class="keywordflow">if</span>(label[i-&gt;first] == 1)</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;                    result.first.push_back(i-&gt;first);</div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;                    result.second.push_back(i-&gt;first);</div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;        }</div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;        <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a704fced132ca5e0e5ea7f7c9ba073a10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraph_1_1_m_s_t_state.html">MSTState</a>&lt;<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&gt; graph::Boruvka </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns the Minimum Cost Spanning tree obtained using Boruvka ALgorithm </li>
</ul>
</p>
<p>Reference Link - <a href="http://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm">Boruvka's ALgorithm</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph on which Boruvka Algorithm is implemented</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MSTState&lt;Graph&gt; state - holds the Minimum Cost Spanning tree after Boruvka Algorithm is applied </dd></dl>

<p>Definition at line <a class="el" href="mst_8hpp_source.html#l00119">119</a> of file <a class="el" href="mst_8hpp_source.html">mst.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    {</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> Graph::VertexType V;</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> Graph::EdgeType E;</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        MSTState&lt;Graph&gt; state(g);</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        DisjointSet&lt;Graph&gt; ds(g);</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        std::map&lt;V, std::tuple&lt;V,V,E&gt;&gt; compMinEdge;</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        </div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        <span class="keywordtype">int</span> size=0;</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        <span class="keywordflow">while</span>(size &lt; state.order()-1)</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        {</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g.begin();i!=g.end();++i)                                   <span class="comment">//finding edge with min weight leaving from every vertex</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;            {</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;                E min = std::numeric_limits&lt;E&gt;::max();</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;                V x;</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;                <span class="keywordflow">for</span>(<span class="keyword">auto</span> j=g.nbegin(i-&gt;first);j!=g.nend(i-&gt;first);++j)</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;                {</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;                    <span class="keywordflow">if</span>(j-&gt;second &lt; min &amp;&amp; !<a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(state.getMst(),i-&gt;first,j-&gt;first))</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;                    {</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;                        min = j-&gt;second;</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;                        x = j-&gt;first;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;                    }</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;                }</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;                <span class="keyword">auto</span> root = ds.findRoot(i-&gt;first);</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;                <span class="keywordflow">if</span>(compMinEdge.find(root) == compMinEdge.end())                     <span class="comment">//finding edge with min weight of every component</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;                    compMinEdge[root] = std::make_tuple(i-&gt;first,x,min);</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span>(std::get&lt;2&gt;(compMinEdge[root]) &gt; min)</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;                    compMinEdge[root] = std::make_tuple(i-&gt;first,x,min);</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;            }</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> it=compMinEdge.begin();it!=compMinEdge.end();++it)            <span class="comment">//inserting edge with min weight of every component to mst</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;            {</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;                <span class="keywordflow">if</span>(ds.Union(std::get&lt;0&gt;(it-&gt;second), std::get&lt;1&gt;(it-&gt;second)))</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;                {</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;                    state.insertEdge(std::get&lt;0&gt;(it-&gt;second), std::get&lt;1&gt;(it-&gt;second), std::get&lt;2&gt;(it-&gt;second));</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;                    size++;</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;                }</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;            }</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;            compMinEdge.clear();</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        }</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;        </div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        <span class="keywordflow">return</span> state;</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a9e003e6fc1c423c859fc0a98cc34a2c0"><div class="ttname"><a href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">graph::isAdjacent</a></div><div class="ttdeci">bool isAdjacent(Graph &amp;g, typename Graph::VertexType x, typename Graph::VertexType y)</div><div class="ttdoc">Returns true if Graph::VertexType x and Graph::VertexType y are adjacent in Graph g...</div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00045">predicates.hpp:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1dbf62eb3deeadedf7afad6aa20f2ad8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> graph::cartesian_product </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns cartesian_product of two Graph datastructures </li>
</ul>
</p>
<p>The set of vertices of cartesian product of two graphs conatins the product of vertices of the two graphs. Two vertices (u,u') and (v,v') are connected by and edge in the cartesian product iff either u = v and u' is adjacent with v' in first graph or u' = v' and u is adjacent with v in second graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g1 - First parameter, a graph datastructure</td></tr>
    <tr><td class="paramname">Graph</td><td>g2 - Second parameter, a graph datastructure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Graph result - Variable to store resultant cartesian_product of Graph g1 and Graph g2 </dd></dl>

<p>Definition at line <a class="el" href="operations_8hpp_source.html#l00174">174</a> of file <a class="el" href="operations_8hpp_source.html">operations.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    {</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        <a class="code" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> result;</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        std::map&lt;int,int&gt; vmap;</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;        <span class="keywordtype">int</span> counter = 1;</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g1.begin();i!=g1.end();++i)</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> j=g2.begin();j!=g2.end();++j)</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;                vmap[<a class="code" href="namespacegraph.html#af2513261fe79cfc0abee1fe4274737a6">pairCompute</a>(i-&gt;first, j-&gt;first)] = counter++;</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=vmap.begin();i!=vmap.end();++i)</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;            result.<a class="code" href="classgraph_1_1_adjacency_list.html#ad182c37f701316c35311e7fcd82df0a1">insertVertex</a>(i-&gt;second);</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=vmap.begin();i!=vmap.end();++i)</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> j=vmap.begin();j!=vmap.end();++j)</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;                <span class="keywordflow">if</span>(i-&gt;second!=j-&gt;second)</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;                {</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;                    <span class="keyword">auto</span> invi = <a class="code" href="namespacegraph.html#a857d0b99072fbb221fb4098e43ae3ea4">pairInvert</a>(i-&gt;first);</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;                    <span class="keyword">auto</span> invj = <a class="code" href="namespacegraph.html#a857d0b99072fbb221fb4098e43ae3ea4">pairInvert</a>(j-&gt;first);</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;                    <span class="keywordflow">if</span>((invi.first == invj.first &amp;&amp; <a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(g2,invi.second , invj.second )) </div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;                        || ( invi.second ==  invj.second &amp;&amp; <a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(g1, invi.first, invj.first)))</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;                        <span class="keywordflow">if</span>(!<a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(result,i-&gt;second,j-&gt;second))</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                            result.insertEdge(i-&gt;second,j-&gt;second,1);</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;                }</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;        <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a79acfc9c3ac45e39bf873e19eff98fab"><div class="ttname"><a href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">graph::Graph</a></div><div class="ttdeci">AdjacencyList&lt; VertexType, EdgeType &gt; Graph</div><div class="ttdoc">using Graph for AdjacencyList<VertexType,EdgeType> </div><div class="ttdef"><b>Definition:</b> <a href="graph_8hpp_source.html#l00017">graph.hpp:17</a></div></div>
<div class="ttc" id="namespacegraph_html_af2513261fe79cfc0abee1fe4274737a6"><div class="ttname"><a href="namespacegraph.html#af2513261fe79cfc0abee1fe4274737a6">graph::pairCompute</a></div><div class="ttdeci">int pairCompute(int x, int y)</div><div class="ttdoc">returns the result of function (x+y) *(x+y+1) / 2 +y </div><div class="ttdef"><b>Definition:</b> <a href="operations_8hpp_source.html#l00140">operations.hpp:140</a></div></div>
<div class="ttc" id="namespacegraph_html_a857d0b99072fbb221fb4098e43ae3ea4"><div class="ttname"><a href="namespacegraph.html#a857d0b99072fbb221fb4098e43ae3ea4">graph::pairInvert</a></div><div class="ttdeci">std::pair&lt; int, int &gt; pairInvert(int z)</div><div class="ttdoc">returns a pair (square root of(8*z+1)-1)/2 - y and z - (w*w+w)/2 </div><div class="ttdef"><b>Definition:</b> <a href="operations_8hpp_source.html#l00151">operations.hpp:151</a></div></div>
<div class="ttc" id="classgraph_1_1_adjacency_list_html_ad182c37f701316c35311e7fcd82df0a1"><div class="ttname"><a href="classgraph_1_1_adjacency_list.html#ad182c37f701316c35311e7fcd82df0a1">graph::AdjacencyList::insertVertex</a></div><div class="ttdeci">void insertVertex(const VertexType &amp;v)</div><div class="ttdoc">function to insert a vertex to a graph </div><div class="ttdef"><b>Definition:</b> <a href="adjlist_8hpp_source.html#l00062">adjlist.hpp:62</a></div></div>
<div class="ttc" id="namespacegraph_html_a9e003e6fc1c423c859fc0a98cc34a2c0"><div class="ttname"><a href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">graph::isAdjacent</a></div><div class="ttdeci">bool isAdjacent(Graph &amp;g, typename Graph::VertexType x, typename Graph::VertexType y)</div><div class="ttdoc">Returns true if Graph::VertexType x and Graph::VertexType y are adjacent in Graph g...</div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00045">predicates.hpp:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aee6e3be7766219c83d5820969266e9b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&gt; graph::Centre </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns a set of vertices constituting the centre in Graph g </li>
</ul>
</p>
<p>Centre of a graph is the set of vertices with minimum eccentricity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>set&lt;typename Graph::VertexType&gt; s - variable to store the centres </dd></dl>

<p>Definition at line <a class="el" href="collections_8hpp_source.html#l00215">215</a> of file <a class="el" href="collections_8hpp_source.html">collections.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    {</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        std::set&lt;typename Graph::VertexType&gt; s;</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        <span class="keyword">auto</span> e=<a class="code" href="namespacegraph.html#a01eff8481121cd9a87cf25132102e240">EcentricityList</a>(g);</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;        <span class="keyword">auto</span> min=e.begin()-&gt;second;</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=e.begin();i!=e.end();++i)</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                <span class="keywordflow">if</span>(i-&gt;second&lt;min)</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                    min=i-&gt;second;</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=e.begin();i!=e.end();++i)</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;            <span class="keywordflow">if</span>(min==i-&gt;second)</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                s.insert(i-&gt;first);</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        <span class="keywordflow">return</span> s;</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a01eff8481121cd9a87cf25132102e240"><div class="ttname"><a href="namespacegraph.html#a01eff8481121cd9a87cf25132102e240">graph::EcentricityList</a></div><div class="ttdeci">std::map&lt; typename Graph::VertexType, typename Graph::EdgeType &gt; EcentricityList(Graph &amp;g, bool check=true)</div><div class="ttdoc">Returns a map of all vertices in Graph g with their corresponding eccentricities </div><div class="ttdef"><b>Definition:</b> <a href="collections_8hpp_source.html#l00184">collections.hpp:184</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4b0983c36b9f41ade0ae678524e8d761"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int graph::chromaticIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns the minimum number of colors used in Edge coloring </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>minimum number of colors used in Edge coloring </dd></dl>

<p>Definition at line <a class="el" href="coloring_8hpp_source.html#l00213">213</a> of file <a class="el" href="coloring_8hpp_source.html">coloring.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    {</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacegraph.html#a1d9628a7c2c3c79cfaa931d059e42658">minEdgeColoring</a>(g).noOfColorsUsed();</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a1d9628a7c2c3c79cfaa931d059e42658"><div class="ttname"><a href="namespacegraph.html#a1d9628a7c2c3c79cfaa931d059e42658">graph::minEdgeColoring</a></div><div class="ttdeci">ColorState&lt; Graph, std::pair&lt; typename Graph::VertexType, typename Graph::VertexType &gt; &gt; minEdgeColoring(Graph &amp;g)</div><div class="ttdoc">Determines the map of edges and corresponding chromatic number for all possible sequence of vertices ...</div><div class="ttdef"><b>Definition:</b> <a href="coloring_8hpp_source.html#l00188">coloring.hpp:188</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8abcbd794e31cc28a3f4e8dac0b5e5c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int graph::chromaticNumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns the chromatic number for a graph object </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no of colors used in vertex coloring </dd></dl>

<p>Definition at line <a class="el" href="coloring_8hpp_source.html#l00157">157</a> of file <a class="el" href="coloring_8hpp_source.html">coloring.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    {</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacegraph.html#a5337b96d2df3cf5fa6c6a68353fc5399">minVertexColoring</a>(g).noOfColorsUsed();</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a5337b96d2df3cf5fa6c6a68353fc5399"><div class="ttname"><a href="namespacegraph.html#a5337b96d2df3cf5fa6c6a68353fc5399">graph::minVertexColoring</a></div><div class="ttdeci">ColorState&lt; Graph, typename Graph::VertexType &gt; minVertexColoring(Graph &amp;g)</div><div class="ttdoc">Determines the map of vertices and corresponding chromatic number for all possible sequence of vertic...</div><div class="ttdef"><b>Definition:</b> <a href="coloring_8hpp_source.html#l00108">coloring.hpp:108</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aae8420fe6320e54097c66e96c541c3b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> graph::complement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns complement of a Graph datastructure </li>
</ul>
</p>
<p>The edges not present in Graph g1 are present in graph result and vice versa</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g1 - Parameter, a graph datastructure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Graph result - Variable to store resultant complement of Graph g1 </dd></dl>

<p>Definition at line <a class="el" href="operations_8hpp_source.html#l00208">208</a> of file <a class="el" href="operations_8hpp_source.html">operations.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    {</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        <a class="code" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> result;</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g1.begin();i!=g1.end();++i)</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;            result.<a class="code" href="classgraph_1_1_adjacency_list.html#ad182c37f701316c35311e7fcd82df0a1">insertVertex</a>(i-&gt;first);</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g1.begin();i!=g1.end();++i)</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> j=g1.begin();j!=g1.end();++j)</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                <span class="keywordflow">if</span>(i-&gt;first!=j-&gt;first &amp;&amp; !(<a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(g1,i-&gt;first,j-&gt;first)))</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;                    result.insertEdge(i-&gt;first,j-&gt;first,1);</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;                </div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a79acfc9c3ac45e39bf873e19eff98fab"><div class="ttname"><a href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">graph::Graph</a></div><div class="ttdeci">AdjacencyList&lt; VertexType, EdgeType &gt; Graph</div><div class="ttdoc">using Graph for AdjacencyList<VertexType,EdgeType> </div><div class="ttdef"><b>Definition:</b> <a href="graph_8hpp_source.html#l00017">graph.hpp:17</a></div></div>
<div class="ttc" id="classgraph_1_1_adjacency_list_html_ad182c37f701316c35311e7fcd82df0a1"><div class="ttname"><a href="classgraph_1_1_adjacency_list.html#ad182c37f701316c35311e7fcd82df0a1">graph::AdjacencyList::insertVertex</a></div><div class="ttdeci">void insertVertex(const VertexType &amp;v)</div><div class="ttdoc">function to insert a vertex to a graph </div><div class="ttdef"><b>Definition:</b> <a href="adjlist_8hpp_source.html#l00062">adjlist.hpp:62</a></div></div>
<div class="ttc" id="namespacegraph_html_a9e003e6fc1c423c859fc0a98cc34a2c0"><div class="ttname"><a href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">graph::isAdjacent</a></div><div class="ttdeci">bool isAdjacent(Graph &amp;g, typename Graph::VertexType x, typename Graph::VertexType y)</div><div class="ttdoc">Returns true if Graph::VertexType x and Graph::VertexType y are adjacent in Graph g...</div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00045">predicates.hpp:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1d26be4aeb4fae8db06762dd366a5714"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int graph::degree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns the total number of edges of <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> v in Graph g </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - First parameter, a graph object</td></tr>
    <tr><td class="paramname"><a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a></td><td>v - Second parameter, a vertex of Graph g</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of edges of <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> v in Graph g </dd></dl>

<p>Definition at line <a class="el" href="enumeration_8hpp_source.html#l00077">77</a> of file <a class="el" href="enumeration_8hpp_source.html">enumeration.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    {</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        <span class="keywordflow">if</span>(!g.isDirected())</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacegraph.html#ab5445f93fca1a98409fe09d12e964b0e">outDegree</a>(g,v);</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacegraph.html#a7cdba5273142484115f58a92ac442213">inDegree</a>(g,v)+<a class="code" href="namespacegraph.html#ab5445f93fca1a98409fe09d12e964b0e">outDegree</a>(g,v);</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a7cdba5273142484115f58a92ac442213"><div class="ttname"><a href="namespacegraph.html#a7cdba5273142484115f58a92ac442213">graph::inDegree</a></div><div class="ttdeci">int inDegree(Graph &amp;g, typename Graph::VertexType v)</div><div class="ttdoc">Returns the number of edges directed towards Graph::VertexType v in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="enumeration_8hpp_source.html#l00050">enumeration.hpp:50</a></div></div>
<div class="ttc" id="namespacegraph_html_ab5445f93fca1a98409fe09d12e964b0e"><div class="ttname"><a href="namespacegraph.html#ab5445f93fca1a98409fe09d12e964b0e">graph::outDegree</a></div><div class="ttdeci">int outDegree(Graph &amp;g, typename Graph::VertexType v)</div><div class="ttdoc">Returns the number of edges directed out of Graph::VertexType v in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="enumeration_8hpp_source.html#l00032">enumeration.hpp:32</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0dec8a130a4c41da242b1bdd9ad254a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>,int&gt; graph::DegreeMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns a list containing all the vertices of Graph g alongwith the total number of edges of each vertex </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>map&lt;typename Graph::VertexType,int&gt; m - variable to store the list </dd></dl>

<p>Definition at line <a class="el" href="collections_8hpp_source.html#l00143">143</a> of file <a class="el" href="collections_8hpp_source.html">collections.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    {</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        std::map&lt;typename Graph::VertexType,int&gt; m;</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g.begin();i!=g.end();++i)</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;            m[i-&gt;first]=<a class="code" href="namespacegraph.html#a1d26be4aeb4fae8db06762dd366a5714">degree</a>(g,i-&gt;first);</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;        <span class="keywordflow">return</span> m;</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a1d26be4aeb4fae8db06762dd366a5714"><div class="ttname"><a href="namespacegraph.html#a1d26be4aeb4fae8db06762dd366a5714">graph::degree</a></div><div class="ttdeci">int degree(Graph &amp;g, typename Graph::VertexType v)</div><div class="ttdoc">Returns the total number of edges of Graph::VertexType v in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="enumeration_8hpp_source.html#l00077">enumeration.hpp:77</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a13481e0c3932354bfc5ca0cd0b3b8fa3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; graph::DegreeSequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns a sequence of total number of edges of all vertices in Graph g in sorted order </li>
</ul>
</p>
<p>The list is sorted in ascending order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;int&gt; ds - variable to store the sequence </dd></dl>

<p>Definition at line <a class="el" href="collections_8hpp_source.html#l00163">163</a> of file <a class="el" href="collections_8hpp_source.html">collections.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    {</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        std::vector&lt;int&gt; ds;</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g.begin();i!=g.end();++i)</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;            ds.push_back(<a class="code" href="namespacegraph.html#a1d26be4aeb4fae8db06762dd366a5714">degree</a>(g,i-&gt;first));</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        std::sort(ds.begin(),ds.end());</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        <span class="keywordflow">return</span> ds;</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a1d26be4aeb4fae8db06762dd366a5714"><div class="ttname"><a href="namespacegraph.html#a1d26be4aeb4fae8db06762dd366a5714">graph::degree</a></div><div class="ttdeci">int degree(Graph &amp;g, typename Graph::VertexType v)</div><div class="ttdoc">Returns the total number of edges of Graph::VertexType v in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="enumeration_8hpp_source.html#l00077">enumeration.hpp:77</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab16770dced352b595abf69d985dcb6c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float graph::Density </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns the density of edges with respect to vertices in Graph g </li>
</ul>
</p>
<p>Density of a graph is obtained by the formula 2*no of edges in graph / (no of vertices of a graph * no of vertices of a graph - 1)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="enumeration_8hpp_source.html#l00155">155</a> of file <a class="el" href="enumeration_8hpp_source.html">enumeration.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    {</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        <span class="keywordflow">return</span> (2.0*<a class="code" href="namespacegraph.html#a5c41719547528ea22af228adcd69668f">Size</a>(g))/(g.order()*(g.order()-1));</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a5c41719547528ea22af228adcd69668f"><div class="ttname"><a href="namespacegraph.html#a5c41719547528ea22af228adcd69668f">graph::Size</a></div><div class="ttdeci">int Size(Graph &amp;g)</div><div class="ttdoc">Returns number of edges in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="enumeration_8hpp_source.html#l00017">enumeration.hpp:17</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4872e63b02686bd6c7c4299198e8b34d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraph_1_1_adjacency_list.html#a38fb996cc38fcb1cf20fbd601594c900">Graph::EdgeType</a> graph::Diameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns the diameter of Graph g </li>
</ul>
</p>
<p>Diameter of a graph is the maximum eccentricity of a graph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max - maximum eccentricity of a graph </dd></dl>

<p>Definition at line <a class="el" href="enumeration_8hpp_source.html#l00136">136</a> of file <a class="el" href="enumeration_8hpp_source.html">enumeration.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    {</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;        <span class="keyword">auto</span> e=<a class="code" href="namespacegraph.html#a01eff8481121cd9a87cf25132102e240">EcentricityList</a>(g);</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        <span class="keyword">auto</span> max=e.begin()-&gt;second;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=e.begin();i!=e.end();++i)</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;                <span class="keywordflow">if</span>(i-&gt;second&gt;max)</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;                    max=i-&gt;second;</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        <span class="keywordflow">return</span> max;</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a01eff8481121cd9a87cf25132102e240"><div class="ttname"><a href="namespacegraph.html#a01eff8481121cd9a87cf25132102e240">graph::EcentricityList</a></div><div class="ttdeci">std::map&lt; typename Graph::VertexType, typename Graph::EdgeType &gt; EcentricityList(Graph &amp;g, bool check=true)</div><div class="ttdoc">Returns a map of all vertices in Graph g with their corresponding eccentricities </div><div class="ttdef"><b>Definition:</b> <a href="collections_8hpp_source.html#l00184">collections.hpp:184</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aeb4c54f3801feaa1914ad866b9f92b4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void graph::displayGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Function to display adjacency list of a graph </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph&amp;</td><td>g - First Parameter, a graph object</td></tr>
    <tr><td class="paramname">std::ostream&amp;</td><td>out = std::cout - Second Paramaeter, an output stream </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="io_8hpp_source.html#l00068">68</a> of file <a class="el" href="io_8hpp_source.html">io.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    {</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> x = g.begin();x!=g.end();++x)</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        {</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;            out&lt;&lt;<span class="stringliteral">&quot;[&quot;</span>&lt;&lt;x-&gt;first&lt;&lt;<span class="stringliteral">&quot;] =&gt;&gt; &quot;</span>;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> y = g.nbegin(x-&gt;first);y!=g.nend(x-&gt;first);++y)</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;            {</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;                out&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>&lt;&lt; y-&gt;first&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>&lt;&lt; y-&gt;second&lt;&lt;<span class="stringliteral">&quot;) &quot;</span>;</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;            }</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;            out&lt;&lt;<span class="stringliteral">&quot;*\n&quot;</span>;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        }</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3d48b42a50e719da807f9645f6c80864"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraph_1_1_s_s_s_p_state.html">SSSPState</a>&lt;<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&gt; graph::Djikstra </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Applies Djikstra's Algorithm on a grpah object </li>
</ul>
</p>
<p>Djikstra's Algorithm findest the shortest path to all vertices from a single source vertex. This function returns the distance array and path array after applying Djikstra's Algorithm for a single source vertex</p><ul>
<li>Reference Link - <a href="http://en.wikipedia.org/wiki/Dijkstra&apos;s_algorithm">Dijkstra's ALgorithm</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - First Parameter, a graph object on which Djikstra's Algorithm is applied</td></tr>
    <tr><td class="paramname">typename</td><td><a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> s - Second Parameter, a vertex of graph g and the source for Djikstra's algorithm</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SSSPState&lt;Graph&gt; state - Contains the modified parent array and distance array after applying Djikstra's Algorithm </dd></dl>

<p>Definition at line <a class="el" href="sssp_8hpp_source.html#l00100">100</a> of file <a class="el" href="sssp_8hpp_source.html">sssp.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    {</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> Graph::VertexType V;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        SSSPState&lt;Graph&gt; state(g,s);</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        ParentArray&lt;Graph&gt;&amp; parent=state.getParentArray();</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        DistanceArray&lt;Graph&gt;&amp; dist=state.getDistanceArray();</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        </div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        PriorityQueue&lt;Graph&gt; pq([&amp;](V x,V y){<span class="keywordflow">return</span> dist[x]&lt;dist[y];},<a class="code" href="namespacegraph.html#ad00b2c13c4512574d4adc236ad14a586">VertexList</a>(g));</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        </div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        <span class="keywordflow">while</span>(!pq.empty())</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        {</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;            pq.heapify();</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;            <span class="keyword">auto</span> u=pq.get();</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;            <a class="code" href="namespacegraph.html#acb243df0343a7f117a0de2817792de58">VisitNeighbours</a>(g,u,[&amp;state,&amp;u](V v){state.relax(u,v);});</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        }</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        </div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        <span class="keywordflow">return</span> state;</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_acb243df0343a7f117a0de2817792de58"><div class="ttname"><a href="namespacegraph.html#acb243df0343a7f117a0de2817792de58">graph::VisitNeighbours</a></div><div class="ttdeci">void VisitNeighbours(Graph &amp;g, typename Graph::VertexType v, F f)</div><div class="ttdoc">function to visit all neighbours of a vertex of a graph </div><div class="ttdef"><b>Definition:</b> <a href="visitors_8hpp_source.html#l00035">visitors.hpp:35</a></div></div>
<div class="ttc" id="namespacegraph_html_ad00b2c13c4512574d4adc236ad14a586"><div class="ttname"><a href="namespacegraph.html#ad00b2c13c4512574d4adc236ad14a586">graph::VertexList</a></div><div class="ttdeci">std::vector&lt; typename Graph::VertexType &gt; VertexList(Graph &amp;g)</div><div class="ttdoc">Returns a list containing names of all the vertices in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="collections_8hpp_source.html#l00034">collections.hpp:34</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a01eff8481121cd9a87cf25132102e240"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>,typename <a class="el" href="classgraph_1_1_adjacency_list.html#a38fb996cc38fcb1cf20fbd601594c900">Graph::EdgeType</a>&gt; graph::EcentricityList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns a map of all vertices in Graph g with their corresponding eccentricities </li>
</ul>
</p>
<p>Eccentricity of a vertex is the maximum distance that can be covered starting from that vertex in a linear acyclic path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>map&lt;typename Graph::VertexType,typename Graph::EdgeType&gt; m - variable to store the mapping </dd></dl>

<p>Definition at line <a class="el" href="collections_8hpp_source.html#l00184">184</a> of file <a class="el" href="collections_8hpp_source.html">collections.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    {</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;        <span class="keywordflow">if</span> (check == <span class="keyword">true</span>)</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;            <span class="keywordflow">if</span>(g.isDirected() || !<a class="code" href="namespacegraph.html#a7ce45abbccf3454e0be31b98aaa4db6a">isConnected</a>(g))</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;                <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Not Possible : &#39;g&#39;-&gt; Undirected and Connected not met ...&quot;</span>);</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        std::map&lt;typename Graph::VertexType,typename Graph::EdgeType&gt; m;</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g.begin();i!=g.end();++i)</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;        {</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;            UniformCostSearch&lt;Graph&gt; ucs(g,i-&gt;first);</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;            ucs();</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;            <span class="keyword">auto</span> d = ucs.getDistanceArray();</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;            <span class="keyword">auto</span> max = d[g.begin()-&gt;first];</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> j = g.begin();j != g.end(); ++j)</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;                <span class="keywordflow">if</span>(d[j-&gt;first] &gt; max)</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;                    max = d[j-&gt;first];</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;             m[i-&gt;first] = max;</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        }</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        <span class="keywordflow">return</span> m;</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a7ce45abbccf3454e0be31b98aaa4db6a"><div class="ttname"><a href="namespacegraph.html#a7ce45abbccf3454e0be31b98aaa4db6a">graph::isConnected</a></div><div class="ttdeci">bool isConnected(Graph &amp;g)</div><div class="ttdoc">Returns true if all vertices of Graph g can be traversed, false otherwise </div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00098">predicates.hpp:98</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a11c6526885c3c807dd6f2e6aef5c6109"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> graph::EdgeContractionMinor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns the graph minor after contracting the edge (x,y) of graph g </li>
</ul>
</p>
<p>Edge contraction removes an edge joning x and y, and merges the vertices x and y</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - First Parameter, a graph datastructure</td></tr>
    <tr><td class="paramname">typename</td><td><a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> x - Second Parameter, a vertex</td></tr>
    <tr><td class="paramname">typename</td><td><a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> y - Third Parameter, a vertex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>g - the graph minor after contracting the edge (x,y) of graph g </dd></dl>

<p>Definition at line <a class="el" href="operations_8hpp_source.html#l00270">270</a> of file <a class="el" href="operations_8hpp_source.html">operations.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    {</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;        <span class="keywordflow">if</span> (g.isDirected())</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Operation not yet supported for directed graphs.&quot;</span>);</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;        <span class="keywordflow">if</span> (!<a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(g,x,y))</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;            <span class="keywordflow">return</span> g;<span class="comment">//this is not vertex identification</span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;        g.removeEdge(x,y);</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> v : <a class="code" href="namespacegraph.html#a13634637f492ab1746d0bf62771116a7">OutVertexList</a>(g,y))</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;            g.insertEdge(x,v,g.weight(y,v));</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;        </div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;        g.removeVertex(y);</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;        </div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;        <span class="keywordflow">return</span> g;</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a13634637f492ab1746d0bf62771116a7"><div class="ttname"><a href="namespacegraph.html#a13634637f492ab1746d0bf62771116a7">graph::OutVertexList</a></div><div class="ttdeci">std::vector&lt; typename Graph::VertexType &gt; OutVertexList(Graph &amp;g, typename Graph::VertexType x)</div><div class="ttdoc">Returns a list containing all the vertices of Graph g having edges originating from Vertex x ...</div><div class="ttdef"><b>Definition:</b> <a href="collections_8hpp_source.html#l00288">collections.hpp:288</a></div></div>
<div class="ttc" id="namespacegraph_html_a9e003e6fc1c423c859fc0a98cc34a2c0"><div class="ttname"><a href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">graph::isAdjacent</a></div><div class="ttdeci">bool isAdjacent(Graph &amp;g, typename Graph::VertexType x, typename Graph::VertexType y)</div><div class="ttdoc">Returns true if Graph::VertexType x and Graph::VertexType y are adjacent in Graph g...</div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00045">predicates.hpp:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aeb9a579f0470be3495792b40b18c30c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> graph::EdgeDeletionSubgraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns the graph after deleting the edge between vertex x and vertex y of graph g1 </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g1 - First Parameter, a graph datastructure</td></tr>
    <tr><td class="paramname">typename</td><td><a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> x - Second Parameter, a vertex</td></tr>
    <tr><td class="paramname">typename</td><td><a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> y - Third Parameter, a vertex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>g1 - the graph after deleting the edge (x,y) of graph g </dd></dl>

<p>Definition at line <a class="el" href="operations_8hpp_source.html#l00233">233</a> of file <a class="el" href="operations_8hpp_source.html">operations.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    {</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        g1.removeEdge(x,y);</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;                </div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        <span class="keywordflow">return</span> g1;</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae8dd696bb3483de793bf5027f4f25474"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::tuple &lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>, typename <a class="el" href="classgraph_1_1_adjacency_list.html#a38fb996cc38fcb1cf20fbd601594c900">Graph::EdgeType</a> &gt; &gt; graph::EdgeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>duplicate</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns a list containing of adjacent vertices with edge weights </li>
</ul>
</p>
<p>This function returns a list containing pairs of vertices which are connected by an edge. The list also contains the edge weights for each edge.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - First parameter, a graph object</td></tr>
    <tr><td class="paramname">bool</td><td>duplicate - Second parameter, to check for duplicate edges</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;std::tuple&lt;typename Graph::VertexType,typename Graph::VertexType,typename Graph::EdgeType&gt;&gt; e - vector to store the list </dd></dl>

<p>Definition at line <a class="el" href="collections_8hpp_source.html#l00064">64</a> of file <a class="el" href="collections_8hpp_source.html">collections.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    {</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        std::vector&lt;std::tuple&lt;typename Graph::VertexType,typename Graph::VertexType,typename Graph::EdgeType&gt;&gt; e;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g.begin();i!=g.end();++i)</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> j=g.nbegin(i-&gt;first);j!=g.nend(i-&gt;first);++j)</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;                <span class="keywordflow">if</span>(!g.isDirected()&amp;&amp; !duplicate)</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;                {</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;                    <span class="keywordflow">if</span>(std::find(e.begin(),e.end(),std::make_tuple(j-&gt;first,i-&gt;first,j-&gt;second))==e.end())</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                        e.push_back(std::make_tuple(i-&gt;first,j-&gt;first,j-&gt;second));</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;                }</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;                    e.push_back(std::make_tuple(i-&gt;first,j-&gt;first,j-&gt;second));</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        <span class="keywordflow">return</span> e;</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a75483eb787f441ecd15fab9dee7f95a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&gt; graph::EulerianCircuit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isStartGiven</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&#160;</td>
          <td class="paramname"><em>start</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns an Eulerian Circuit of a graph </li>
</ul>
</p>
<p>An Eulerian Circuit is a circuit that visits every edge of a graph exactly once. This employs Hierholzer's algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;V&gt; path - an Eulerian Circuit </dd></dl>

<p>Definition at line <a class="el" href="collections_8hpp_source.html#l00371">371</a> of file <a class="el" href="collections_8hpp_source.html">collections.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    {</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;        <span class="keywordflow">if</span>(!<a class="code" href="namespacegraph.html#a87376811d5603b78059b9def7f026e03">isEulerian</a>(g))</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;g is not eulerian ...&quot;</span>);</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> Graph::VertexType V;</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;        std::vector&lt;V&gt; <a class="code" href="namespacegraph_1_1gen.html#afaa26a5be847642e993500ad7e5cf41a">path</a>;</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;        std::set&lt;V&gt; visited;</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;        std::map&lt;V,std::vector&lt;V&gt;&gt; unusedEdges;                             <span class="comment">// unused edges FROM each vertex</span></div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g.begin();i!=g.end();++i)</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> j=g.nbegin(i-&gt;first);j!=g.nend(i-&gt;first);++j)</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;                unusedEdges[i-&gt;first].push_back(j-&gt;first);</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;        <span class="keywordflow">if</span>(!isStartGiven)</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;            start = g.begin()-&gt;first;</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;        <span class="keyword">auto</span> it = path.begin();</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;        </div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;        <span class="keywordflow">while</span>(1)</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;        {</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;            V v = start;</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;            visited.insert(v);</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;            <span class="keywordflow">if</span>(path.empty())</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;                it = path.insert(it,v);</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;                </div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;            <span class="keywordflow">do</span></div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;            {</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;                <span class="keywordflow">for</span>(<span class="keyword">auto</span> w=g.nbegin(v);w!=g.nend(v);++w)                    <span class="comment">// basic cycle find</span></div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;                {</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;                    <span class="keyword">auto</span> it1 = std::find(unusedEdges[v].begin(), unusedEdges[v].end(), w-&gt;first);</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;                    <span class="keywordflow">if</span>( it1 != unusedEdges[v].end())</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;                    {</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;                        unusedEdges[v].erase(it1);</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;                        <span class="keywordflow">if</span>(!g.isDirected())</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;                        {</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;                            <span class="keyword">auto</span> it2 = std::find(unusedEdges[w-&gt;first].begin(), unusedEdges[w-&gt;first].end(), v);</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;                            unusedEdges[w-&gt;first].erase(it2);</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;                        }</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;                        visited.insert(w-&gt;first);</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;                        it = path.insert(it,w-&gt;first);</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;                        v = w-&gt;first;</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;                    }</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;                }</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;            }<span class="keywordflow">while</span>(v != start);</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;            </div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;            <span class="keywordtype">bool</span> flag = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g.begin();i!=g.end();++i)                                               <span class="comment">// check for existence of other cycles</span></div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;                <span class="keywordflow">if</span>(visited.find(i-&gt;first)!=visited.end() &amp;&amp; !unusedEdges[i-&gt;first].empty())</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;                {</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;                    start = i-&gt;first;</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;                    it = std::find(path.begin(), path.end(), i-&gt;first);</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;                    flag = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;                }</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;            </div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;            <span class="keywordflow">if</span>(flag == <span class="keyword">false</span>)</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;        }</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;        </div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;        <span class="keywordflow">return</span> path;</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a87376811d5603b78059b9def7f026e03"><div class="ttname"><a href="namespacegraph.html#a87376811d5603b78059b9def7f026e03">graph::isEulerian</a></div><div class="ttdeci">bool isEulerian(Graph &amp;g)</div><div class="ttdoc">Returns true if degree of all vertices in Graph g is even and Graph g is connected, false otherwise </div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00223">predicates.hpp:223</a></div></div>
<div class="ttc" id="namespacegraph_1_1gen_html_afaa26a5be847642e993500ad7e5cf41a"><div class="ttname"><a href="namespacegraph_1_1gen.html#afaa26a5be847642e993500ad7e5cf41a">graph::gen::path</a></div><div class="ttdeci">Graph&lt; int, int &gt; path(std::vector&lt; int &gt; args, int start=1)</div><div class="ttdoc">Returns a path graph </div><div class="ttdef"><b>Definition:</b> <a href="generate_8hpp_source.html#l00078">generate.hpp:78</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a408865b98504ee5a16776610216adacf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&gt; graph::EulerianTrail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns an Eulerian trail of a graph </li>
</ul>
</p>
<p>An Eulerian Trail is a trail that visits every edge of a graph exactly once. This employs an augemnted version of Hierholzer's algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;V&gt; path - an Eulerian Trail </dd></dl>

<p>Definition at line <a class="el" href="collections_8hpp_source.html#l00441">441</a> of file <a class="el" href="collections_8hpp_source.html">collections.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;    {</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;        <span class="keywordflow">if</span>(<a class="code" href="namespacegraph.html#a87376811d5603b78059b9def7f026e03">isEulerian</a>(g))</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;        {</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;            <span class="keyword">auto</span> <a class="code" href="namespacegraph_1_1gen.html#afaa26a5be847642e993500ad7e5cf41a">path</a> = <a class="code" href="namespacegraph.html#a75483eb787f441ecd15fab9dee7f95a3">EulerianCircuit</a>(g);</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;            <a class="code" href="namespacegraph_1_1gen.html#afaa26a5be847642e993500ad7e5cf41a">path</a>.pop_back();</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacegraph_1_1gen.html#afaa26a5be847642e993500ad7e5cf41a">path</a>;</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;        }</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;        <span class="keywordflow">if</span>(!<a class="code" href="namespacegraph.html#ab7885ff6225a44cb3132023197cbafa8">isSemiEulerian</a>(g))</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;g is not semi-eulerian ...&quot;</span>);</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;        std::vector&lt;typename Graph::VertexType&gt; oddVertices;</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g.begin();i!=g.end();++i)</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;            <span class="keywordflow">if</span>(<a class="code" href="namespacegraph.html#a1d26be4aeb4fae8db06762dd366a5714">degree</a>(g,i-&gt;first)%2!=0)</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;                oddVertices.push_back(i-&gt;first);</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;        g.insertEdge(oddVertices[0],oddVertices[1],1);</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;        <span class="keyword">auto</span> <a class="code" href="namespacegraph_1_1gen.html#afaa26a5be847642e993500ad7e5cf41a">path</a> = <a class="code" href="namespacegraph.html#a75483eb787f441ecd15fab9dee7f95a3">EulerianCircuit</a>(g,oddVertices[0]);</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;        <a class="code" href="namespacegraph_1_1gen.html#afaa26a5be847642e993500ad7e5cf41a">path</a>.pop_back();</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacegraph_1_1gen.html#afaa26a5be847642e993500ad7e5cf41a">path</a>;</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_ab7885ff6225a44cb3132023197cbafa8"><div class="ttname"><a href="namespacegraph.html#ab7885ff6225a44cb3132023197cbafa8">graph::isSemiEulerian</a></div><div class="ttdeci">bool isSemiEulerian(Graph &amp;g)</div><div class="ttdoc">Returns true if degree of exactly two vertices in Graph g is even and Graph g is connected, false otherwise </div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00257">predicates.hpp:257</a></div></div>
<div class="ttc" id="namespacegraph_html_a75483eb787f441ecd15fab9dee7f95a3"><div class="ttname"><a href="namespacegraph.html#a75483eb787f441ecd15fab9dee7f95a3">graph::EulerianCircuit</a></div><div class="ttdeci">std::vector&lt; typename Graph::VertexType &gt; EulerianCircuit(Graph g, bool isStartGiven=false, typename Graph::VertexType start=1)</div><div class="ttdoc">Returns an Eulerian Circuit of a graph </div><div class="ttdef"><b>Definition:</b> <a href="collections_8hpp_source.html#l00371">collections.hpp:371</a></div></div>
<div class="ttc" id="namespacegraph_html_a87376811d5603b78059b9def7f026e03"><div class="ttname"><a href="namespacegraph.html#a87376811d5603b78059b9def7f026e03">graph::isEulerian</a></div><div class="ttdeci">bool isEulerian(Graph &amp;g)</div><div class="ttdoc">Returns true if degree of all vertices in Graph g is even and Graph g is connected, false otherwise </div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00223">predicates.hpp:223</a></div></div>
<div class="ttc" id="namespacegraph_1_1gen_html_afaa26a5be847642e993500ad7e5cf41a"><div class="ttname"><a href="namespacegraph_1_1gen.html#afaa26a5be847642e993500ad7e5cf41a">graph::gen::path</a></div><div class="ttdeci">Graph&lt; int, int &gt; path(std::vector&lt; int &gt; args, int start=1)</div><div class="ttdoc">Returns a path graph </div><div class="ttdef"><b>Definition:</b> <a href="generate_8hpp_source.html#l00078">generate.hpp:78</a></div></div>
<div class="ttc" id="namespacegraph_html_a1d26be4aeb4fae8db06762dd366a5714"><div class="ttname"><a href="namespacegraph.html#a1d26be4aeb4fae8db06762dd366a5714">graph::degree</a></div><div class="ttdeci">int degree(Graph &amp;g, typename Graph::VertexType v)</div><div class="ttdoc">Returns the total number of edges of Graph::VertexType v in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="enumeration_8hpp_source.html#l00077">enumeration.hpp:77</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4a67cccc220255b81655c5306f6a9c93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraph_1_1_a_p_s_p_state.html">APSPState</a>&lt;<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&gt; graph::FloydRoyWarshall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Function to implement Floyd-Roy-Warshall Algorithm </li>
</ul>
</p>
<p>Returns the path matrix and distance matrix of a graph after applying Floyd-Roy-Warshall Algorithm. This algorithm finds the shortest path possible between all pairs of vertices. It returns both the shortest path and the shortest distance between all pairs of vertices. Reference Lin - <a href="http://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm">FLoyd-Roy-Warshall ALgorithm</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object on which Floyd-Roy-Warshall Algorithm is applied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APSPState&lt;Graph&gt; state - Contains the modified path matrix and distance matrix after applying Floyd-Roy-Warshall Algorithm </dd></dl>

<p>Definition at line <a class="el" href="apsp_8hpp_source.html#l00139">139</a> of file <a class="el" href="apsp_8hpp_source.html">apsp.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    {</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> std::map&lt;std::pair&lt;typename Graph::VertexType,typename Graph::VertexType&gt;,<span class="keyword">typename</span> Graph::EdgeType&gt; AM;</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        APSPState&lt;Graph&gt; state(g);</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        </div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> k=g.begin();k!=g.end();++k) </div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g.begin();i!=g.end();++i)</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> j=g.begin();j!=g.end();++j)   </div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;                    state.relax(k-&gt;first, i-&gt;first, j-&gt;first);</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;        <span class="keywordflow">return</span> state;</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a07a6cc4daa6537b9129112cf6ddd6d58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&gt; graph::HamiltonianCycle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns a Hamiltonian Cycle of a graph </li>
</ul>
</p>
<p>A Hamiltonian Cycle is a cycle that visits every vertex of a graph exactly once.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;V&gt; path - a Hamiltonian Cycle </dd></dl>

<p>Definition at line <a class="el" href="collections_8hpp_source.html#l00506">506</a> of file <a class="el" href="collections_8hpp_source.html">collections.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;    {</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;        <span class="keyword">auto</span> vlist = <a class="code" href="namespacegraph.html#ad00b2c13c4512574d4adc236ad14a586">VertexList</a>(g);</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;        std::sort(vlist.begin(),vlist.end());</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;        </div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;        <span class="keywordflow">do</span></div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;        {</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;            <span class="keywordtype">bool</span> flag = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;            <span class="keyword">auto</span> v = vlist[0];</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=1;i&lt;vlist.size();++i)</div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;            {</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;                <span class="keywordflow">if</span>(!<a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(g,v,vlist[i]))</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;                {</div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;                    flag = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;                    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;                }</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;                v = vlist[i];</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;            }</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;            <span class="keywordflow">if</span>(flag == <span class="keyword">true</span> &amp;&amp; <a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(g,vlist.front(),vlist.back()))</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;            {</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;                vlist.push_back(vlist.front());</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;                <span class="keywordflow">return</span> vlist;</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;            }</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;        }<span class="keywordflow">while</span>(std::next_permutation(vlist.begin(),vlist.end()));</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;        </div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;g is not hamiltonian ...&quot;</span>);</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_ad00b2c13c4512574d4adc236ad14a586"><div class="ttname"><a href="namespacegraph.html#ad00b2c13c4512574d4adc236ad14a586">graph::VertexList</a></div><div class="ttdeci">std::vector&lt; typename Graph::VertexType &gt; VertexList(Graph &amp;g)</div><div class="ttdoc">Returns a list containing names of all the vertices in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="collections_8hpp_source.html#l00034">collections.hpp:34</a></div></div>
<div class="ttc" id="namespacegraph_html_a9e003e6fc1c423c859fc0a98cc34a2c0"><div class="ttname"><a href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">graph::isAdjacent</a></div><div class="ttdeci">bool isAdjacent(Graph &amp;g, typename Graph::VertexType x, typename Graph::VertexType y)</div><div class="ttdoc">Returns true if Graph::VertexType x and Graph::VertexType y are adjacent in Graph g...</div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00045">predicates.hpp:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aee8d40d943191c30a9cb94a4edccd9c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&gt; graph::HamiltonianPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns a Hamiltonian Path of a graph </li>
</ul>
</p>
<p>A Hamiltonian Path is a path that visits every vertex of a graph exactly once.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;V&gt; path - a Hamiltonian Path </dd></dl>

<p>Definition at line <a class="el" href="collections_8hpp_source.html#l00471">471</a> of file <a class="el" href="collections_8hpp_source.html">collections.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;    {</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;        <span class="keyword">auto</span> vlist = <a class="code" href="namespacegraph.html#ad00b2c13c4512574d4adc236ad14a586">VertexList</a>(g);</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;        std::sort(vlist.begin(),vlist.end());</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;        </div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;        <span class="keywordflow">do</span></div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;        {</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;            <span class="keywordtype">bool</span> flag = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;            <span class="keyword">auto</span> v = vlist[0];</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=1;i&lt;vlist.size();++i)</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;            {</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;                <span class="keywordflow">if</span>(!<a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(g,v,vlist[i]))</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;                {</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;                    flag = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;                    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;                }</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;                v = vlist[i];</div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;            }</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;            <span class="keywordflow">if</span>(flag == <span class="keyword">true</span>)</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;                <span class="keywordflow">return</span> vlist;</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;        }<span class="keywordflow">while</span>(std::next_permutation(vlist.begin(),vlist.end()));</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;        </div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;g is not semi-hamiltonian ...&quot;</span>);</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_ad00b2c13c4512574d4adc236ad14a586"><div class="ttname"><a href="namespacegraph.html#ad00b2c13c4512574d4adc236ad14a586">graph::VertexList</a></div><div class="ttdeci">std::vector&lt; typename Graph::VertexType &gt; VertexList(Graph &amp;g)</div><div class="ttdoc">Returns a list containing names of all the vertices in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="collections_8hpp_source.html#l00034">collections.hpp:34</a></div></div>
<div class="ttc" id="namespacegraph_html_a9e003e6fc1c423c859fc0a98cc34a2c0"><div class="ttname"><a href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">graph::isAdjacent</a></div><div class="ttdeci">bool isAdjacent(Graph &amp;g, typename Graph::VertexType x, typename Graph::VertexType y)</div><div class="ttdoc">Returns true if Graph::VertexType x and Graph::VertexType y are adjacent in Graph g...</div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00045">predicates.hpp:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7cdba5273142484115f58a92ac442213"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int graph::inDegree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns the number of edges directed towards <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> v in Graph g </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - First parameter, a graph object</td></tr>
    <tr><td class="paramname"><a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a></td><td>v - Second parameter, a vertex of Graph g</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int conunt - the number of edges directed towards <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> v in Graph g </dd></dl>

<p>Definition at line <a class="el" href="enumeration_8hpp_source.html#l00050">50</a> of file <a class="el" href="enumeration_8hpp_source.html">enumeration.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    {</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        <span class="keywordtype">int</span> count=0;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        <span class="keywordflow">if</span>(!g.isDirected())</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacegraph.html#ab5445f93fca1a98409fe09d12e964b0e">outDegree</a>(g,v);</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        {</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> x=g.begin();x!=g.end();++x)</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;            {</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                <span class="keywordflow">for</span>(<span class="keyword">auto</span> y=g.nbegin(x-&gt;first);y!=g.nend(x-&gt;first);++y)</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;                    <span class="keywordflow">if</span>(y-&gt;first==v)</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;                        count++;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;            }</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;            <span class="keywordflow">return</span> count;</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        }</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_ab5445f93fca1a98409fe09d12e964b0e"><div class="ttname"><a href="namespacegraph.html#ab5445f93fca1a98409fe09d12e964b0e">graph::outDegree</a></div><div class="ttdeci">int outDegree(Graph &amp;g, typename Graph::VertexType v)</div><div class="ttdoc">Returns the number of edges directed out of Graph::VertexType v in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="enumeration_8hpp_source.html#l00032">enumeration.hpp:32</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9af6c970655d50a0bd498d4d20b4519a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> graph::intersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns intersection of two Graph datastructures </li>
</ul>
</p>
<p>An intersection of two graphs contains the vertices common to both graphs and corresponding edges from both graphs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g1 - First parameter, a graph datastructure</td></tr>
    <tr><td class="paramname">Graph</td><td>g2 - Second parameter, a graph datastructure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Graph result - Variable to store resultant intersection of Graph g1 and Graph g2 </dd></dl>

<p>Definition at line <a class="el" href="operations_8hpp_source.html#l00058">58</a> of file <a class="el" href="operations_8hpp_source.html">operations.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    {</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        <a class="code" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> result;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g1.begin();i!=g1.end();++i)</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;            <span class="keywordflow">if</span>(<a class="code" href="namespacegraph.html#ac94693eb5b7a9ba65b1da69d8ecde02b">isVertex</a>(g2,i-&gt;first))</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;                result.<a class="code" href="classgraph_1_1_adjacency_list.html#ad182c37f701316c35311e7fcd82df0a1">insertVertex</a>(i-&gt;first);</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=result.begin();i!=result.end();++i)</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> j=g1.nbegin(i-&gt;first);j!=g1.nend(i-&gt;first);++j)</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;                <span class="keywordflow">if</span>(<a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(g2,i-&gt;first,j-&gt;first))</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;                    <span class="keywordflow">if</span>(!<a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(result,i-&gt;first,j-&gt;first))</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;                        result.insertEdge(i-&gt;first,j-&gt;first,1);</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;                        </div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a79acfc9c3ac45e39bf873e19eff98fab"><div class="ttname"><a href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">graph::Graph</a></div><div class="ttdeci">AdjacencyList&lt; VertexType, EdgeType &gt; Graph</div><div class="ttdoc">using Graph for AdjacencyList<VertexType,EdgeType> </div><div class="ttdef"><b>Definition:</b> <a href="graph_8hpp_source.html#l00017">graph.hpp:17</a></div></div>
<div class="ttc" id="classgraph_1_1_adjacency_list_html_ad182c37f701316c35311e7fcd82df0a1"><div class="ttname"><a href="classgraph_1_1_adjacency_list.html#ad182c37f701316c35311e7fcd82df0a1">graph::AdjacencyList::insertVertex</a></div><div class="ttdeci">void insertVertex(const VertexType &amp;v)</div><div class="ttdoc">function to insert a vertex to a graph </div><div class="ttdef"><b>Definition:</b> <a href="adjlist_8hpp_source.html#l00062">adjlist.hpp:62</a></div></div>
<div class="ttc" id="namespacegraph_html_ac94693eb5b7a9ba65b1da69d8ecde02b"><div class="ttname"><a href="namespacegraph.html#ac94693eb5b7a9ba65b1da69d8ecde02b">graph::isVertex</a></div><div class="ttdeci">bool isVertex(Graph &amp;g, typename Graph::VertexType x)</div><div class="ttdoc">Returns true if Graph::VertexType x is a vertex of Graph g, false otherwise </div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00028">predicates.hpp:28</a></div></div>
<div class="ttc" id="namespacegraph_html_a9e003e6fc1c423c859fc0a98cc34a2c0"><div class="ttname"><a href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">graph::isAdjacent</a></div><div class="ttdeci">bool isAdjacent(Graph &amp;g, typename Graph::VertexType x, typename Graph::VertexType y)</div><div class="ttdoc">Returns true if Graph::VertexType x and Graph::VertexType y are adjacent in Graph g...</div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00045">predicates.hpp:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a656e6ef2a2bc5570745b2c5be0d8c53e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&gt; graph::InVertexList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns a list containing all vertices of Graph g having edges ending at Vertex x </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - First Parameter, a graph object</td></tr>
    <tr><td class="paramname">typename</td><td><a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> x - Second parameter, a vertex of Graph g</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>map&lt;typename Graph::VertexType&gt; v - variable to store the list </dd></dl>

<p>Definition at line <a class="el" href="collections_8hpp_source.html#l00309">309</a> of file <a class="el" href="collections_8hpp_source.html">collections.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    {</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;        <span class="keywordflow">if</span>(!g.isDirected())</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacegraph.html#a13634637f492ab1746d0bf62771116a7">OutVertexList</a>(g,x);</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;        {</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;            std::vector&lt;typename Graph::VertexType&gt; v;</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g.begin();i!=g.end();++i)</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;            {</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;                <span class="keyword">auto</span> it=g.nfind(i-&gt;first,x);</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;                <span class="keywordflow">if</span>(it!=g.nend(i-&gt;first))</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;                    v.push_back(i-&gt;first);</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;            }</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;            <span class="keywordflow">return</span> v;</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;        }           </div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a13634637f492ab1746d0bf62771116a7"><div class="ttname"><a href="namespacegraph.html#a13634637f492ab1746d0bf62771116a7">graph::OutVertexList</a></div><div class="ttdeci">std::vector&lt; typename Graph::VertexType &gt; OutVertexList(Graph &amp;g, typename Graph::VertexType x)</div><div class="ttdoc">Returns a list containing all the vertices of Graph g having edges originating from Vertex x ...</div><div class="ttdef"><b>Definition:</b> <a href="collections_8hpp_source.html#l00288">collections.hpp:288</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9e003e6fc1c423c859fc0a98cc34a2c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isAdjacent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> x and <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> y are adjacent in Graph g, false otherwise </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - First parameter, a graph object</td></tr>
    <tr><td class="paramname"><a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a></td><td>x- Second parameter, the first vertex</td></tr>
    <tr><td class="paramname"><a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a></td><td>y- Third parameter, the second vertex </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00045">45</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    {</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        <span class="keywordflow">if</span>(<a class="code" href="namespacegraph.html#ac94693eb5b7a9ba65b1da69d8ecde02b">isVertex</a>(g,x) &amp;&amp; <a class="code" href="namespacegraph.html#ac94693eb5b7a9ba65b1da69d8ecde02b">isVertex</a>(g,y))</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;            <span class="keywordflow">return</span> g.nfind(x,y)!=g.nend(x);</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_ac94693eb5b7a9ba65b1da69d8ecde02b"><div class="ttname"><a href="namespacegraph.html#ac94693eb5b7a9ba65b1da69d8ecde02b">graph::isVertex</a></div><div class="ttdeci">bool isVertex(Graph &amp;g, typename Graph::VertexType x)</div><div class="ttdoc">Returns true if Graph::VertexType x is a vertex of Graph g, false otherwise </div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00028">predicates.hpp:28</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a978e407919e226890fdb46d72866ef04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isBipartite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if Graph g is bipartite, false otherwise </li>
</ul>
</p>
<p>A graph is bipartite iff its vertices can be divided into two disjoint sets U and V such that every edge connects a vertex in U to one in V.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00144">144</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    {</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        BreadthFirstSearch&lt;Graph&gt; bfs(g,g.begin()-&gt;first);</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;        <span class="keywordtype">bool</span> result = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;        std::map&lt;typename Graph::VertexType, int&gt; label;</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        label[g.begin()-&gt;first] = 1;</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;        bfs.setp4([&amp;label](<span class="keyword">const</span> <span class="keyword">typename</span> Graph::VertexType&amp; x, <span class="keyword">const</span> <span class="keyword">typename</span> Graph::VertexType&amp; y)</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;        {</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;            label[y] = -label[x];</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        });</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;        bfs.setp3([&amp;result,&amp;label](<span class="keyword">const</span> <span class="keyword">typename</span> Graph::VertexType&amp; x, <span class="keyword">const</span> <span class="keyword">typename</span> Graph::VertexType&amp; y)</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        {</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;            <span class="keywordflow">if</span>(label[x] == label[y])</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;            {</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                result = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;            }</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        });</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        bfs();</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3b26f07c06de8b3ab3249efc3756afab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isCentre </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> x is at the centre of Graph g, false otherwise </li>
</ul>
</p>
<p>A center of a graph is a set of vertices with minimum eccentricity</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - First parameter, a graph object</td></tr>
    <tr><td class="paramname"><a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a></td><td>x- Second parameter, the vertex </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00477">477</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;    {</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;        <span class="keyword">auto</span> s=<a class="code" href="namespacegraph.html#aee6e3be7766219c83d5820969266e9b7">Centre</a>(g);</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        <span class="keywordflow">return</span> s.find(x)!=s.end();</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_aee6e3be7766219c83d5820969266e9b7"><div class="ttname"><a href="namespacegraph.html#aee6e3be7766219c83d5820969266e9b7">graph::Centre</a></div><div class="ttdeci">std::set&lt; typename Graph::VertexType &gt; Centre(Graph &amp;g)</div><div class="ttdoc">Returns a set of vertices constituting the centre in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="collections_8hpp_source.html#l00215">collections.hpp:215</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a94bd95d92a70961e82d3751b1eb2918a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isComplement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if edges present in Graph g are not present in Graph h and vice versa (neglecting self loops), false otherwise </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - First parameter, a graph object</td></tr>
    <tr><td class="paramname">Graph</td><td>h - Second parameter, a graph object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00417">417</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    {</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> x=g.begin();x!=g.end();++x)</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> y=g.begin();y!=g.end();++y)</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;                <span class="keywordflow">if</span> (x!=y)</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;                    <span class="keywordflow">if</span>(<a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(g,x-&gt;first,y-&gt;first) &amp;&amp; <a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(h,x-&gt;first,y-&gt;first))</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;                        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;                    </div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a9e003e6fc1c423c859fc0a98cc34a2c0"><div class="ttname"><a href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">graph::isAdjacent</a></div><div class="ttdeci">bool isAdjacent(Graph &amp;g, typename Graph::VertexType x, typename Graph::VertexType y)</div><div class="ttdoc">Returns true if Graph::VertexType x and Graph::VertexType y are adjacent in Graph g...</div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00045">predicates.hpp:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1ac12e0ca7f5cb7c38f5e27fb7b2b0c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if atleast one edge is present between all combination of vertices (except self loops) in Graph g, false otherwise </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00394">394</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    {</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> x=g.begin();x!=g.end();++x)</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> y=g.begin();y!=g.end();++y)</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;            {</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;                <span class="keywordflow">if</span> (x!=y &amp;&amp; !(<a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(g,x-&gt;first,y-&gt;first)))</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;                <span class="keywordflow">if</span> (g.isDirected() &amp;&amp; !(<a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(g,y-&gt;first,x-&gt;first)))</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;            }</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a9e003e6fc1c423c859fc0a98cc34a2c0"><div class="ttname"><a href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">graph::isAdjacent</a></div><div class="ttdeci">bool isAdjacent(Graph &amp;g, typename Graph::VertexType x, typename Graph::VertexType y)</div><div class="ttdoc">Returns true if Graph::VertexType x and Graph::VertexType y are adjacent in Graph g...</div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00045">predicates.hpp:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a273935d9afa64a48f4e1879195b6ddec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if Graph g1 is a component of Graph g2, false otherwise </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g1 - First parameter, a graph object</td></tr>
    <tr><td class="paramname">Graph</td><td>g2 - Second parameter, a graph object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00178">178</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    {</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        <span class="keywordflow">if</span>(!(<a class="code" href="namespacegraph.html#a7ce45abbccf3454e0be31b98aaa4db6a">isConnected</a>(g1)&amp;&amp;<a class="code" href="namespacegraph.html#a87f38bde9b380bda9aaaab4413d7e5d1">isSubgraph</a>(g1,g2)))</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        BreadthFirstSearch&lt;Graph&gt; bfs(g2,g1.begin()-&gt;first);</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        bfs();</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        <span class="keyword">auto</span> d=bfs.getDistanceArray();</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        <span class="keywordflow">if</span>(d.size()!=g1.order())</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a87f38bde9b380bda9aaaab4413d7e5d1"><div class="ttname"><a href="namespacegraph.html#a87f38bde9b380bda9aaaab4413d7e5d1">graph::isSubgraph</a></div><div class="ttdeci">bool isSubgraph(Graph &amp;g, Graph &amp;h)</div><div class="ttdoc">Returns true if Graph g is a subgraph of Graph h, false otherwise </div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00061">predicates.hpp:61</a></div></div>
<div class="ttc" id="namespacegraph_html_a7ce45abbccf3454e0be31b98aaa4db6a"><div class="ttname"><a href="namespacegraph.html#a7ce45abbccf3454e0be31b98aaa4db6a">graph::isConnected</a></div><div class="ttdeci">bool isConnected(Graph &amp;g)</div><div class="ttdoc">Returns true if all vertices of Graph g can be traversed, false otherwise </div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00098">predicates.hpp:98</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7ce45abbccf3454e0be31b98aaa4db6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isConnected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if all vertices of Graph g can be traversed, false otherwise </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00098">98</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    {</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        BreadthFirstSearch&lt;Graph&gt; bfs(g,g.begin()-&gt;first);</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        bfs();</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        <span class="keyword">auto</span> d=bfs.getDistanceArray();</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        </div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        <span class="keywordflow">return</span> d.size()==g.order();</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a872940ce015a9f1d8c6900c76a1532e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isConnected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> y can be reached from <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> x in Graph g, false otherwise </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - First parameter, a graph object</td></tr>
    <tr><td class="paramname"><a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a></td><td>x- Second parameter, the first vertex</td></tr>
    <tr><td class="paramname"><a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a></td><td>y- Third parameter, the second vertex </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00119">119</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    {</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        Search&lt;Graph,Queue&gt; searchObject(g,x);</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        <span class="keywordtype">bool</span> connected=<span class="keyword">false</span>;</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        searchObject.setp2([&amp;connected,&amp;y](<span class="keyword">const</span> <span class="keyword">typename</span> Graph::VertexType&amp; v)</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        {</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;            <span class="keywordflow">if</span>(v==y)</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;            {</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;                connected=<span class="keyword">true</span>;</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;            }</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;        });</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        searchObject();</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        <span class="keywordflow">return</span> connected;</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae36dc23681dd3e0fb72cad8a1c803d75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isCyclic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if there is atleast one path starting and ending at the same vertex in Graph g, false otherwise </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00452">452</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;    {</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;        Search&lt;Graph,Stack&gt; searchObject(g,g.begin()-&gt;first);</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;        <span class="keywordtype">bool</span> cyclic=<span class="keyword">false</span>;</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;        searchObject.setp3([&amp;cyclic](<span class="keyword">const</span> <span class="keyword">typename</span> Graph::VertexType&amp; x, <span class="keyword">const</span> <span class="keyword">typename</span> Graph::VertexType&amp; y)</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;        {</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;            cyclic=<span class="keyword">true</span>;</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;        });</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;        searchObject();</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;        <span class="keywordflow">return</span> cyclic;</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af9c937901146559ee61bfad0879cca51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isEdgeless </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if there are no edges in Graph g, false otherwise </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00434">434</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    {</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> x=g.begin();x!=g.end();++x)</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> y=g.begin();y!=g.end();++y)</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;                <span class="keywordflow">if</span>(<a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(g,x-&gt;first,y-&gt;first))</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;                </div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;            </div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a9e003e6fc1c423c859fc0a98cc34a2c0"><div class="ttname"><a href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">graph::isAdjacent</a></div><div class="ttdeci">bool isAdjacent(Graph &amp;g, typename Graph::VertexType x, typename Graph::VertexType y)</div><div class="ttdoc">Returns true if Graph::VertexType x and Graph::VertexType y are adjacent in Graph g...</div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00045">predicates.hpp:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0df7a3b7971d7f1f2f51aabb43d9aa26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if there are no vertex in Graph g, false otherwise </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00507">507</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;    {</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;        <span class="keywordflow">return</span> (g.begin()==g.end());</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a87376811d5603b78059b9def7f026e03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isEulerian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if degree of all vertices in Graph g is even and Graph g is connected, false otherwise </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00223">223</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    {</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;        <span class="keywordflow">if</span> (g.isDirected())</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        {</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> x=g.begin();x!=g.end();++x)</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;            {</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespacegraph.html#a1d26be4aeb4fae8db06762dd366a5714">degree</a>(g,x-&gt;first)==0)</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespacegraph.html#a7cdba5273142484115f58a92ac442213">inDegree</a>(g,x-&gt;first)!=<a class="code" href="namespacegraph.html#ab5445f93fca1a98409fe09d12e964b0e">outDegree</a>(g,x-&gt;first))</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;            }</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        }</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacegraph.html#a7ce45abbccf3454e0be31b98aaa4db6a">isConnected</a>(g))</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        {</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> x=g.begin();x!=g.end();++x)</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;            {</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;                <span class="keywordtype">int</span> k=<a class="code" href="namespacegraph.html#a1d26be4aeb4fae8db06762dd366a5714">degree</a>(g,x-&gt;first);</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;                <span class="keywordflow">if</span>(k%2!=0)</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;            }</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;        }</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a7cdba5273142484115f58a92ac442213"><div class="ttname"><a href="namespacegraph.html#a7cdba5273142484115f58a92ac442213">graph::inDegree</a></div><div class="ttdeci">int inDegree(Graph &amp;g, typename Graph::VertexType v)</div><div class="ttdoc">Returns the number of edges directed towards Graph::VertexType v in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="enumeration_8hpp_source.html#l00050">enumeration.hpp:50</a></div></div>
<div class="ttc" id="namespacegraph_html_ab5445f93fca1a98409fe09d12e964b0e"><div class="ttname"><a href="namespacegraph.html#ab5445f93fca1a98409fe09d12e964b0e">graph::outDegree</a></div><div class="ttdeci">int outDegree(Graph &amp;g, typename Graph::VertexType v)</div><div class="ttdoc">Returns the number of edges directed out of Graph::VertexType v in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="enumeration_8hpp_source.html#l00032">enumeration.hpp:32</a></div></div>
<div class="ttc" id="namespacegraph_html_a7ce45abbccf3454e0be31b98aaa4db6a"><div class="ttname"><a href="namespacegraph.html#a7ce45abbccf3454e0be31b98aaa4db6a">graph::isConnected</a></div><div class="ttdeci">bool isConnected(Graph &amp;g)</div><div class="ttdoc">Returns true if all vertices of Graph g can be traversed, false otherwise </div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00098">predicates.hpp:98</a></div></div>
<div class="ttc" id="namespacegraph_html_a1d26be4aeb4fae8db06762dd366a5714"><div class="ttname"><a href="namespacegraph.html#a1d26be4aeb4fae8db06762dd366a5714">graph::degree</a></div><div class="ttdeci">int degree(Graph &amp;g, typename Graph::VertexType v)</div><div class="ttdoc">Returns the total number of edges of Graph::VertexType v in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="enumeration_8hpp_source.html#l00077">enumeration.hpp:77</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3d6e15c7fd1c835e1ea1b9c518945371"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isHamiltonian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if the graph is Hamiltoian, false other wise </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00311">311</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    {</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        <span class="keyword">auto</span> vlist = <a class="code" href="namespacegraph.html#ad00b2c13c4512574d4adc236ad14a586">VertexList</a>(g);</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;        std::sort(vlist.begin(),vlist.end());</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;        </div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;        <span class="keywordflow">do</span></div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;        {</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;            <span class="keywordtype">bool</span> flag = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;            <span class="keyword">auto</span> v = vlist[0];</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=1;i&lt;vlist.size();++i)</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;            {</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;                <span class="keywordflow">if</span>(!<a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(g,v,vlist[i]))</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;                {</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;                    flag = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;                    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;                }</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;                v = vlist[i];</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;            }</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;            <span class="keywordflow">if</span>(flag == <span class="keyword">true</span> &amp;&amp; <a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(g,vlist.front(),vlist.back()))</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;        }<span class="keywordflow">while</span>(std::next_permutation(vlist.begin(),vlist.end()));</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;        </div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_ad00b2c13c4512574d4adc236ad14a586"><div class="ttname"><a href="namespacegraph.html#ad00b2c13c4512574d4adc236ad14a586">graph::VertexList</a></div><div class="ttdeci">std::vector&lt; typename Graph::VertexType &gt; VertexList(Graph &amp;g)</div><div class="ttdoc">Returns a list containing names of all the vertices in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="collections_8hpp_source.html#l00034">collections.hpp:34</a></div></div>
<div class="ttc" id="namespacegraph_html_a9e003e6fc1c423c859fc0a98cc34a2c0"><div class="ttname"><a href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">graph::isAdjacent</a></div><div class="ttdeci">bool isAdjacent(Graph &amp;g, typename Graph::VertexType x, typename Graph::VertexType y)</div><div class="ttdoc">Returns true if Graph::VertexType x and Graph::VertexType y are adjacent in Graph g...</div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00045">predicates.hpp:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a013ebe74e89fec9fd096c9bdfe4bb162"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isHypoHamiltonian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if the graph is Hypo Hamiltoian, false other wise </li>
</ul>
</p>
<p>A graph is Hypo Hamiltonian if all vertex deletion subgraphs of the graph are hamiltonian.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00372">372</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    {</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g.begin();i!=g.end();++i)</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;        {</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;            <span class="keyword">auto</span> h=<a class="code" href="namespacegraph.html#a239b80d07aa07ae2eadbbb9731f40b43">VertexDeletionSubgraph</a>(g,i-&gt;first);</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;            <span class="keywordflow">if</span>(!<a class="code" href="namespacegraph.html#a3d6e15c7fd1c835e1ea1b9c518945371">isHamiltonian</a>(h))</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;            {</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;            }</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;        }</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;        </div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a3d6e15c7fd1c835e1ea1b9c518945371"><div class="ttname"><a href="namespacegraph.html#a3d6e15c7fd1c835e1ea1b9c518945371">graph::isHamiltonian</a></div><div class="ttdeci">bool isHamiltonian(Graph g)</div><div class="ttdoc">Returns true if the graph is Hamiltoian, false other wise </div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00311">predicates.hpp:311</a></div></div>
<div class="ttc" id="namespacegraph_html_a239b80d07aa07ae2eadbbb9731f40b43"><div class="ttname"><a href="namespacegraph.html#a239b80d07aa07ae2eadbbb9731f40b43">graph::VertexDeletionSubgraph</a></div><div class="ttdeci">Graph VertexDeletionSubgraph(Graph g1, typename Graph::VertexType x)</div><div class="ttdoc">Returns the graph after deleting the vertex x of graph g1 </div><div class="ttdef"><b>Definition:</b> <a href="operations_8hpp_source.html#l00249">operations.hpp:249</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a83b63f2ad24994baeb1f6235e2ae7c73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isPeriphery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> x lies at the periphery of Graph g, false otherwise </li>
</ul>
</p>
<p>A periphery of a graph is a set of vertices with maximum eccentricity</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - First parameter, a graph object</td></tr>
    <tr><td class="paramname"><a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a></td><td>x- Second parameter, the vertex </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00495">495</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;    {</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;        <span class="keyword">auto</span> s=<a class="code" href="namespacegraph.html#aae686ba4060d119ff11440eca676fcbf">Periphery</a>(g);</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;        <span class="keywordflow">return</span> s.find(x)!=s.end();</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_aae686ba4060d119ff11440eca676fcbf"><div class="ttname"><a href="namespacegraph.html#aae686ba4060d119ff11440eca676fcbf">graph::Periphery</a></div><div class="ttdeci">std::set&lt; typename Graph::VertexType &gt; Periphery(Graph &amp;g)</div><div class="ttdoc">Returns a set of vertices constituting the periphery in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="collections_8hpp_source.html#l00241">collections.hpp:241</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ace6db7031876867ba5a173dd9828f7fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isRegular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if degree of all vertices in Graph g is equal, false otherwise </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00198">198</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    {</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        <span class="keywordtype">int</span> k=<a class="code" href="namespacegraph.html#a1d26be4aeb4fae8db06762dd366a5714">degree</a>(g,g.begin()-&gt;first);</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        </div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> x=g.begin();x!=g.end();++x)</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        {</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;            <span class="keywordflow">if</span> (g.isDirected())</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;            {</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespacegraph.html#a7cdba5273142484115f58a92ac442213">inDegree</a>(g,x-&gt;first)!=<a class="code" href="namespacegraph.html#ab5445f93fca1a98409fe09d12e964b0e">outDegree</a>(g,x-&gt;first))</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;            }</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;            <span class="keywordflow">if</span>(k!=<a class="code" href="namespacegraph.html#a1d26be4aeb4fae8db06762dd366a5714">degree</a>(g,x-&gt;first))</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;            </div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;        }</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a7cdba5273142484115f58a92ac442213"><div class="ttname"><a href="namespacegraph.html#a7cdba5273142484115f58a92ac442213">graph::inDegree</a></div><div class="ttdeci">int inDegree(Graph &amp;g, typename Graph::VertexType v)</div><div class="ttdoc">Returns the number of edges directed towards Graph::VertexType v in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="enumeration_8hpp_source.html#l00050">enumeration.hpp:50</a></div></div>
<div class="ttc" id="namespacegraph_html_ab5445f93fca1a98409fe09d12e964b0e"><div class="ttname"><a href="namespacegraph.html#ab5445f93fca1a98409fe09d12e964b0e">graph::outDegree</a></div><div class="ttdeci">int outDegree(Graph &amp;g, typename Graph::VertexType v)</div><div class="ttdoc">Returns the number of edges directed out of Graph::VertexType v in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="enumeration_8hpp_source.html#l00032">enumeration.hpp:32</a></div></div>
<div class="ttc" id="namespacegraph_html_a1d26be4aeb4fae8db06762dd366a5714"><div class="ttname"><a href="namespacegraph.html#a1d26be4aeb4fae8db06762dd366a5714">graph::degree</a></div><div class="ttdeci">int degree(Graph &amp;g, typename Graph::VertexType v)</div><div class="ttdoc">Returns the total number of edges of Graph::VertexType v in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="enumeration_8hpp_source.html#l00077">enumeration.hpp:77</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab7885ff6225a44cb3132023197cbafa8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isSemiEulerian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if degree of exactly two vertices in Graph g is even and Graph g is connected, false otherwise </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00257">257</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;    {</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;        <span class="keywordflow">if</span> (g.isDirected())</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;        {</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;            <span class="keywordtype">bool</span> out = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;            <span class="keywordtype">bool</span> in = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> x=g.begin();x!=g.end();++x)</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;            {</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespacegraph.html#a1d26be4aeb4fae8db06762dd366a5714">degree</a>(g,x-&gt;first)==0)</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;                <span class="keywordtype">int</span> <span class="keywordtype">id</span> = <a class="code" href="namespacegraph.html#a7cdba5273142484115f58a92ac442213">inDegree</a>(g,x-&gt;first);</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;                <span class="keywordtype">int</span> od = <a class="code" href="namespacegraph.html#ab5445f93fca1a98409fe09d12e964b0e">outDegree</a>(g,x-&gt;first);</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;                <span class="keywordflow">if</span> (<span class="keywordtype">id</span>==od)</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;                {</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;                    <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;                }</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;                <span class="keywordflow">if</span> (out == 1 + in)</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;                {</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                    <span class="keywordflow">if</span>(out)</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;                        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                    <span class="keywordflow">else</span> out = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;                }</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (in == 1 + out)</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;                {</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;                    <span class="keywordflow">if</span>(in)</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;                        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;                    <span class="keywordflow">else</span> in = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;                }</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;            }</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;        }</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacegraph.html#a7ce45abbccf3454e0be31b98aaa4db6a">isConnected</a>(g))</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        {</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;            <span class="keywordtype">int</span> count=0;</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> x=g.begin();x!=g.end();++x)</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;            {</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;                <span class="keywordtype">int</span> k=<a class="code" href="namespacegraph.html#a1d26be4aeb4fae8db06762dd366a5714">degree</a>(g,x-&gt;first);</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;                <span class="keywordflow">if</span>(k%2!=0)</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;                    count++;</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;            }</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;            <span class="keywordflow">if</span>(count==2)</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;        }</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a7cdba5273142484115f58a92ac442213"><div class="ttname"><a href="namespacegraph.html#a7cdba5273142484115f58a92ac442213">graph::inDegree</a></div><div class="ttdeci">int inDegree(Graph &amp;g, typename Graph::VertexType v)</div><div class="ttdoc">Returns the number of edges directed towards Graph::VertexType v in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="enumeration_8hpp_source.html#l00050">enumeration.hpp:50</a></div></div>
<div class="ttc" id="namespacegraph_html_ab5445f93fca1a98409fe09d12e964b0e"><div class="ttname"><a href="namespacegraph.html#ab5445f93fca1a98409fe09d12e964b0e">graph::outDegree</a></div><div class="ttdeci">int outDegree(Graph &amp;g, typename Graph::VertexType v)</div><div class="ttdoc">Returns the number of edges directed out of Graph::VertexType v in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="enumeration_8hpp_source.html#l00032">enumeration.hpp:32</a></div></div>
<div class="ttc" id="namespacegraph_html_a7ce45abbccf3454e0be31b98aaa4db6a"><div class="ttname"><a href="namespacegraph.html#a7ce45abbccf3454e0be31b98aaa4db6a">graph::isConnected</a></div><div class="ttdeci">bool isConnected(Graph &amp;g)</div><div class="ttdoc">Returns true if all vertices of Graph g can be traversed, false otherwise </div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00098">predicates.hpp:98</a></div></div>
<div class="ttc" id="namespacegraph_html_a1d26be4aeb4fae8db06762dd366a5714"><div class="ttname"><a href="namespacegraph.html#a1d26be4aeb4fae8db06762dd366a5714">graph::degree</a></div><div class="ttdeci">int degree(Graph &amp;g, typename Graph::VertexType v)</div><div class="ttdoc">Returns the total number of edges of Graph::VertexType v in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="enumeration_8hpp_source.html#l00077">enumeration.hpp:77</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a66ac00d84e69840a1b8311235177010c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isSemiHamiltonian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if the graph is Semi-Hamiltoian, false other wise </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00340">340</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    {</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;        <span class="keyword">auto</span> vlist = <a class="code" href="namespacegraph.html#ad00b2c13c4512574d4adc236ad14a586">VertexList</a>(g);</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;        std::sort(vlist.begin(),vlist.end());</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;        </div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;        <span class="keywordflow">do</span></div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;        {</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;            <span class="keywordtype">bool</span> flag = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;            <span class="keyword">auto</span> v = vlist[0];</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=1;i&lt;vlist.size();++i)</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;            {</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;                <span class="keywordflow">if</span>(!<a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(g,v,vlist[i]))</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;                {</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;                    flag = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;                    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;                }</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;                v = vlist[i];</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;            }</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;            <span class="keywordflow">if</span>(flag == <span class="keyword">true</span>)</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;        }<span class="keywordflow">while</span>(std::next_permutation(vlist.begin(),vlist.end()));</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;        </div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_ad00b2c13c4512574d4adc236ad14a586"><div class="ttname"><a href="namespacegraph.html#ad00b2c13c4512574d4adc236ad14a586">graph::VertexList</a></div><div class="ttdeci">std::vector&lt; typename Graph::VertexType &gt; VertexList(Graph &amp;g)</div><div class="ttdoc">Returns a list containing names of all the vertices in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="collections_8hpp_source.html#l00034">collections.hpp:34</a></div></div>
<div class="ttc" id="namespacegraph_html_a9e003e6fc1c423c859fc0a98cc34a2c0"><div class="ttname"><a href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">graph::isAdjacent</a></div><div class="ttdeci">bool isAdjacent(Graph &amp;g, typename Graph::VertexType x, typename Graph::VertexType y)</div><div class="ttdoc">Returns true if Graph::VertexType x and Graph::VertexType y are adjacent in Graph g...</div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00045">predicates.hpp:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1afd196b78ff4dfdfabba1d35303f01f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isSpanningSubgraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if Graph g is a spanning subgraph of Graph h, false otherwise </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - First parameter, a graph object</td></tr>
    <tr><td class="paramname">Graph</td><td>h - Second parameter, a graph object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00084">84</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    {</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        <span class="keywordflow">if</span>(g.order()==h.order() &amp;&amp; <a class="code" href="namespacegraph.html#a87f38bde9b380bda9aaaab4413d7e5d1">isSubgraph</a>(g,h))</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a87f38bde9b380bda9aaaab4413d7e5d1"><div class="ttname"><a href="namespacegraph.html#a87f38bde9b380bda9aaaab4413d7e5d1">graph::isSubgraph</a></div><div class="ttdeci">bool isSubgraph(Graph &amp;g, Graph &amp;h)</div><div class="ttdoc">Returns true if Graph g is a subgraph of Graph h, false otherwise </div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00061">predicates.hpp:61</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1033a999aa291d80628b2d6dc0ea0911"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isSparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if number of edges in Graph g is less than or equal to twice the number of vertices in graph g, false otherwise </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00519">519</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;    {</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;        <span class="keywordtype">int</span> count=0;</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> x=g.begin();x!=g.end();x++)</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> y=g.begin();y!=g.end();y++)</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;                <span class="keywordflow">if</span>(x!=y &amp;&amp; <a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(g,x-&gt;first,y-&gt;first))</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;                    count++;</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;                <span class="keywordflow">if</span> (g.isDirected())</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;                    <span class="keywordflow">for</span> (<span class="keyword">auto</span> x=g.begin();x!=g.end();x++)</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;                        <span class="keywordflow">for</span> (<span class="keyword">auto</span> y=g.begin();y!=g.end();y++)</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;                            <span class="keywordflow">if</span>(<a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(g,y-&gt;first,x-&gt;first))</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;                                count++;</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;                            <span class="keywordtype">int</span> n=(g.isDirected()?4*g.order():2*g.order());</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;                        <span class="keywordflow">if</span> (count&lt;=n)</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;                            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;                        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a9e003e6fc1c423c859fc0a98cc34a2c0"><div class="ttname"><a href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">graph::isAdjacent</a></div><div class="ttdeci">bool isAdjacent(Graph &amp;g, typename Graph::VertexType x, typename Graph::VertexType y)</div><div class="ttdoc">Returns true if Graph::VertexType x and Graph::VertexType y are adjacent in Graph g...</div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00045">predicates.hpp:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a87f38bde9b380bda9aaaab4413d7e5d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isSubgraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if Graph g is a subgraph of Graph h, false otherwise </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - First parameter, a graph object</td></tr>
    <tr><td class="paramname">Graph</td><td>h - Second parameter, a graph object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00061">61</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    {</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        <span class="keywordflow">if</span>(h.order()&lt;g.order())</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g.begin();i!=g.end();++i)</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;            <span class="keywordflow">if</span>(!(<a class="code" href="namespacegraph.html#ac94693eb5b7a9ba65b1da69d8ecde02b">isVertex</a>(h,i-&gt;first)))</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g.begin();i!=g.end();++i)</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;                <span class="keywordflow">for</span>(<span class="keyword">auto</span> j=g.nbegin(i-&gt;first);j!=g.nend(i-&gt;first);++j)</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;                    <span class="keywordflow">if</span>(!(<a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(h,i-&gt;first,j-&gt;first)))</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;                        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_ac94693eb5b7a9ba65b1da69d8ecde02b"><div class="ttname"><a href="namespacegraph.html#ac94693eb5b7a9ba65b1da69d8ecde02b">graph::isVertex</a></div><div class="ttdeci">bool isVertex(Graph &amp;g, typename Graph::VertexType x)</div><div class="ttdoc">Returns true if Graph::VertexType x is a vertex of Graph g, false otherwise </div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00028">predicates.hpp:28</a></div></div>
<div class="ttc" id="namespacegraph_html_a9e003e6fc1c423c859fc0a98cc34a2c0"><div class="ttname"><a href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">graph::isAdjacent</a></div><div class="ttdeci">bool isAdjacent(Graph &amp;g, typename Graph::VertexType x, typename Graph::VertexType y)</div><div class="ttdoc">Returns true if Graph::VertexType x and Graph::VertexType y are adjacent in Graph g...</div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00045">predicates.hpp:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a881b9e13435114913b8a76518ac081dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if Graph g is a tree, false otherwise </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00543">543</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;    {</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;        <span class="keywordflow">if</span>(!<a class="code" href="namespacegraph.html#ae36dc23681dd3e0fb72cad8a1c803d75">isCyclic</a>(g)&amp;&amp;<a class="code" href="namespacegraph.html#a7ce45abbccf3454e0be31b98aaa4db6a">isConnected</a>(g))</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_ae36dc23681dd3e0fb72cad8a1c803d75"><div class="ttname"><a href="namespacegraph.html#ae36dc23681dd3e0fb72cad8a1c803d75">graph::isCyclic</a></div><div class="ttdeci">bool isCyclic(Graph &amp;g)</div><div class="ttdoc">Returns true if there is atleast one path starting and ending at the same vertex in Graph g...</div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00452">predicates.hpp:452</a></div></div>
<div class="ttc" id="namespacegraph_html_a7ce45abbccf3454e0be31b98aaa4db6a"><div class="ttname"><a href="namespacegraph.html#a7ce45abbccf3454e0be31b98aaa4db6a">graph::isConnected</a></div><div class="ttdeci">bool isConnected(Graph &amp;g)</div><div class="ttdoc">Returns true if all vertices of Graph g can be traversed, false otherwise </div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00098">predicates.hpp:98</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac94693eb5b7a9ba65b1da69d8ecde02b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graph::isVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns true if <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> x is a vertex of Graph g, false otherwise </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - First parameter, a graph object</td></tr>
    <tr><td class="paramname"><a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a></td><td>x- Second parameter, the vertex </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="predicates_8hpp_source.html#l00028">28</a> of file <a class="el" href="predicates_8hpp_source.html">predicates.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    {</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;        <span class="keywordflow">return</span> g.find(x)!=g.end();</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a18d32f8690fbd7a81934e9e434c848ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> graph::join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns natural join of two Graph datastructures </li>
</ul>
</p>
<p>A natural join of two graphs is a union of two graphs with some additional edges. The additional edges joins all vertices of first graph with all vertices of second graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g1 - First parameter, a graph datastructure</td></tr>
    <tr><td class="paramname">Graph</td><td>g2 - Second parameter, a graph datastructure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Graph result - Variable to store resultant natural join of Graph g1 and Graph g2 </dd></dl>

<p>Definition at line <a class="el" href="operations_8hpp_source.html#l00085">85</a> of file <a class="el" href="operations_8hpp_source.html">operations.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    {</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        <a class="code" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> result=<a class="code" href="namespacegraph.html#a27ec4176d88500a4a129ac2a3361a9ee">Union</a>(g1,g2);</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g1.begin();i!=g1.end();++i)</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> j=g2.begin();j!=g2.end();++j)</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;                result.insertEdge(i-&gt;first,j-&gt;first,1);</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;         </div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;        <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a79acfc9c3ac45e39bf873e19eff98fab"><div class="ttname"><a href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">graph::Graph</a></div><div class="ttdeci">AdjacencyList&lt; VertexType, EdgeType &gt; Graph</div><div class="ttdoc">using Graph for AdjacencyList<VertexType,EdgeType> </div><div class="ttdef"><b>Definition:</b> <a href="graph_8hpp_source.html#l00017">graph.hpp:17</a></div></div>
<div class="ttc" id="namespacegraph_html_a27ec4176d88500a4a129ac2a3361a9ee"><div class="ttname"><a href="namespacegraph.html#a27ec4176d88500a4a129ac2a3361a9ee">graph::Union</a></div><div class="ttdeci">Graph Union(Graph g1, Graph g2)</div><div class="ttdoc">Returns union of two Graph datastructures </div><div class="ttdef"><b>Definition:</b> <a href="operations_8hpp_source.html#l00027">operations.hpp:27</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa7f5e9de42cb2e5653ecadd4b16e19b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraph_1_1_m_s_t_state.html">MSTState</a>&lt;<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&gt; graph::Kruskal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns the Minimum Cost Spanning tree obtained using Kruskal's ALgorithm </li>
</ul>
</p>
<p>Reference Link - <a href="http://en.wikipedia.org/wiki/Kruskal%27s_algorithm">Kruskal's ALgorithm</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - First Parameter, a graph on which Kruskal's Algorithm is implemented</td></tr>
    <tr><td class="paramname">F</td><td>callback - Second Parameter, a hook to facilitate different functions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MSTState&lt;Graph&gt; state - holds the Minimum Cost Spanning tree after Kruskal's Algorithm is applied </dd></dl>

<p>Definition at line <a class="el" href="mst_8hpp_source.html#l00085">85</a> of file <a class="el" href="mst_8hpp_source.html">mst.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    {</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        MSTState&lt;Graph&gt; state(g); </div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        <span class="keyword">auto</span> e = <a class="code" href="namespacegraph.html#a347482999e282edb2e82de37cad981de">sortedEdgeList</a>(g,<span class="keyword">false</span>);</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        DisjointSet&lt;Graph&gt; ds(g);</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        </div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        <span class="keywordtype">int</span> size=0;</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;        <span class="keywordflow">for</span>(uint i=0;i&lt;e.size();++i)</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;        {</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;            <span class="keywordflow">if</span>(size == state.order()-1)</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;            <span class="keyword">auto</span> x = std::get&lt;0&gt;(e[i]);</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;            <span class="keyword">auto</span> y = std::get&lt;1&gt;(e[i]);</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;            <span class="keyword">auto</span> w = std::get&lt;2&gt;(e[i]);</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;            <span class="keywordflow">if</span>(ds.Union(x,y) == <span class="keyword">true</span>)</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;            {</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;                state.insertEdge(x,y,w);</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;                callback(x,y,w);</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;                size++;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;            }</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        }</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        <span class="keywordflow">return</span> state;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a347482999e282edb2e82de37cad981de"><div class="ttname"><a href="namespacegraph.html#a347482999e282edb2e82de37cad981de">graph::sortedEdgeList</a></div><div class="ttdeci">std::vector&lt; std::tuple&lt; typename Graph::VertexType, typename Graph::VertexType, typename Graph::EdgeType &gt; &gt; sortedEdgeList(Graph &amp;g, bool duplicate=true)</div><div class="ttdoc">eturns a list containing of adjacent vertices with edge weights </div><div class="ttdef"><b>Definition:</b> <a href="collections_8hpp_source.html#l00126">collections.hpp:126</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af8bce75612817a0cd0e1349602b4fe1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> graph::line </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns line graph of a Graph datastructure </li>
</ul>
</p>
<ul>
<li>each vertex of L(G) represents an edge of G,</li>
<li>two vertices of L(G) are adjacent if and only if their corresponding edges share a common endpoint in G.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g1 - Parameter, a graph datastructure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Graph result - Variable to store resultant line graph of Graph g1 </dd></dl>

<p>Definition at line <a class="el" href="operations_8hpp_source.html#l00297">297</a> of file <a class="el" href="operations_8hpp_source.html">operations.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    {</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;        <a class="code" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> result;</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;        <span class="keyword">auto</span> elist = <a class="code" href="namespacegraph.html#ae8dd696bb3483de793bf5027f4f25474">EdgeList</a>(g,<span class="keyword">false</span>);</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=elist.begin();i!=elist.end();++i)</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;            result.insertVertex(<a class="code" href="namespacegraph.html#af2513261fe79cfc0abee1fe4274737a6">pairCompute</a>(std::get&lt;0&gt;(*i),std::get&lt;1&gt;(*i)));</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=result.begin();i!=result.end();++i)</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> j=result.begin();j!=result.end();++j)</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;                <span class="keywordflow">if</span>(i-&gt;first != j-&gt;first)</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;                {</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;                    <span class="keyword">auto</span> invi=<a class="code" href="namespacegraph.html#a857d0b99072fbb221fb4098e43ae3ea4">pairInvert</a>(i-&gt;first);</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;                    <span class="keyword">auto</span> invj=<a class="code" href="namespacegraph.html#a857d0b99072fbb221fb4098e43ae3ea4">pairInvert</a>(j-&gt;first);</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                    <span class="keywordflow">if</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;                    (</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                        invi.first == invj.first ||</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;                        invi.first == invj.second ||</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;                        invi.second == invj.second ||</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;                        invi.second == invj.first</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                    )</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;                        result.insertEdge(i-&gt;first,j-&gt;first,1);</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;                }</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;        <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a79acfc9c3ac45e39bf873e19eff98fab"><div class="ttname"><a href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">graph::Graph</a></div><div class="ttdeci">AdjacencyList&lt; VertexType, EdgeType &gt; Graph</div><div class="ttdoc">using Graph for AdjacencyList<VertexType,EdgeType> </div><div class="ttdef"><b>Definition:</b> <a href="graph_8hpp_source.html#l00017">graph.hpp:17</a></div></div>
<div class="ttc" id="namespacegraph_html_ae8dd696bb3483de793bf5027f4f25474"><div class="ttname"><a href="namespacegraph.html#ae8dd696bb3483de793bf5027f4f25474">graph::EdgeList</a></div><div class="ttdeci">std::vector&lt; std::tuple&lt; typename Graph::VertexType, typename Graph::VertexType, typename Graph::EdgeType &gt; &gt; EdgeList(Graph &amp;g, bool duplicate=true)</div><div class="ttdoc">Returns a list containing of adjacent vertices with edge weights </div><div class="ttdef"><b>Definition:</b> <a href="collections_8hpp_source.html#l00064">collections.hpp:64</a></div></div>
<div class="ttc" id="namespacegraph_html_af2513261fe79cfc0abee1fe4274737a6"><div class="ttname"><a href="namespacegraph.html#af2513261fe79cfc0abee1fe4274737a6">graph::pairCompute</a></div><div class="ttdeci">int pairCompute(int x, int y)</div><div class="ttdoc">returns the result of function (x+y) *(x+y+1) / 2 +y </div><div class="ttdef"><b>Definition:</b> <a href="operations_8hpp_source.html#l00140">operations.hpp:140</a></div></div>
<div class="ttc" id="namespacegraph_html_a857d0b99072fbb221fb4098e43ae3ea4"><div class="ttname"><a href="namespacegraph.html#a857d0b99072fbb221fb4098e43ae3ea4">graph::pairInvert</a></div><div class="ttdeci">std::pair&lt; int, int &gt; pairInvert(int z)</div><div class="ttdoc">returns a pair (square root of(8*z+1)-1)/2 - y and z - (w*w+w)/2 </div><div class="ttdef"><b>Definition:</b> <a href="operations_8hpp_source.html#l00151">operations.hpp:151</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1d9628a7c2c3c79cfaa931d059e42658"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraph_1_1_color_state.html">ColorState</a>&lt; <a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>, std::pair &lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> &gt; &gt; graph::minEdgeColoring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Determines the map of edges and corresponding chromatic number for all possible sequence of vertices </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph&amp;</td><td>g - Parameter, a graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classgraph_1_1_color_state.html" title="Class to hold the current state of the required datastructures during any graph coloring algorithm...">ColorState</a>&lt;Graph, std::pair&lt;V,V&gt;&gt; cstate_g cstate_g - map of edges and corresponding chromatic number for all possible sequence of vertices </dd></dl>

<p>Definition at line <a class="el" href="coloring_8hpp_source.html#l00188">188</a> of file <a class="el" href="coloring_8hpp_source.html">coloring.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    {</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> Graph::VertexType V;</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;        std::map&lt; std::pair&lt;V,V&gt;, <span class="keywordtype">int</span>&gt; resultmap;</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        <span class="keyword">auto</span> l = <a class="code" href="namespacegraph.html#af8bce75612817a0cd0e1349602b4fe1e">line</a>(g);</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="comment">//         auto cstate_l = minVertexColoring(l);</span></div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        <span class="keyword">auto</span> cstate_l = <a class="code" href="namespacegraph.html#ad0a694b54f33b86d8783c64c13f5d456">WelshPowellColoring</a>(l);</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;        <span class="keyword">auto</span> cmap=cstate_l.getColorMap();</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=cmap.begin();i!=cmap.end();++i)</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;        {</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;            <span class="keyword">auto</span> inv = pair_invert(i-&gt;first);</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;            resultmap[inv] = i-&gt;second;</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;            resultmap[{inv.second,inv.first}] = i-&gt;second;</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        }</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        ColorState&lt;Graph, std::pair&lt;V,V&gt;&gt; cstate_g(g,resultmap,cstate_l.noOfColorsUsed());</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        <span class="keywordflow">return</span> cstate_g;</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_af8bce75612817a0cd0e1349602b4fe1e"><div class="ttname"><a href="namespacegraph.html#af8bce75612817a0cd0e1349602b4fe1e">graph::line</a></div><div class="ttdeci">Graph line(Graph g)</div><div class="ttdoc">Returns line graph of a Graph datastructure </div><div class="ttdef"><b>Definition:</b> <a href="operations_8hpp_source.html#l00297">operations.hpp:297</a></div></div>
<div class="ttc" id="namespacegraph_html_ad0a694b54f33b86d8783c64c13f5d456"><div class="ttname"><a href="namespacegraph.html#ad0a694b54f33b86d8783c64c13f5d456">graph::WelshPowellColoring</a></div><div class="ttdeci">ColorState&lt; Graph, typename Graph::VertexType &gt; WelshPowellColoring(Graph &amp;g)</div><div class="ttdoc">Vertex Coloring algorithm using some heuristics. Determines the map of vertices and corresponding chr...</div><div class="ttdef"><b>Definition:</b> <a href="coloring_8hpp_source.html#l00141">coloring.hpp:141</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0eaa9849e824b0835a601917cb41034c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraph_1_1_vertex_attribute.html">VertexAttribute</a>&lt;<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>, int&gt; graph::minVertexColorAssignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns a mapping of vertices and their corresponding colours </li>
</ul>
</p>
<p>this employs a brute force approach. the vertex colouring is done using the minimum number of colours possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph&amp;</td><td>g - Parameter, a graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VertexAttribute&lt;Graph, int&gt; vattr - the mapping of vertices and their colours </dd></dl>

<p>Definition at line <a class="el" href="collections_8hpp_source.html#l00337">337</a> of file <a class="el" href="collections_8hpp_source.html">collections.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    {</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;        <span class="keyword">auto</span> state = <a class="code" href="namespacegraph.html#a5337b96d2df3cf5fa6c6a68353fc5399">minVertexColoring</a>(g);</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;        VertexAttribute&lt;Graph, int&gt; vattr(state.getColorMap());</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;        <span class="keywordflow">return</span> vattr;</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a5337b96d2df3cf5fa6c6a68353fc5399"><div class="ttname"><a href="namespacegraph.html#a5337b96d2df3cf5fa6c6a68353fc5399">graph::minVertexColoring</a></div><div class="ttdeci">ColorState&lt; Graph, typename Graph::VertexType &gt; minVertexColoring(Graph &amp;g)</div><div class="ttdoc">Determines the map of vertices and corresponding chromatic number for all possible sequence of vertic...</div><div class="ttdef"><b>Definition:</b> <a href="coloring_8hpp_source.html#l00108">coloring.hpp:108</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5337b96d2df3cf5fa6c6a68353fc5399"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraph_1_1_color_state.html">ColorState</a>&lt;<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&gt; graph::minVertexColoring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Determines the map of vertices and corresponding chromatic number for all possible sequence of vertices </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph&amp;</td><td>g - Parameter, a graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ColorState&lt;Graph, typename Graph::VertexType&gt; min_cstate - map of vertices and corresponding chromatic number for all possible sequence of vertices </dd></dl>

<p>Definition at line <a class="el" href="coloring_8hpp_source.html#l00108">108</a> of file <a class="el" href="coloring_8hpp_source.html">coloring.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    {</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        <span class="keywordtype">int</span> min_color=g.order()+1,i=0;</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        ColorState&lt;Graph, typename Graph::VertexType&gt; min_cstate;</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        <span class="keyword">auto</span> vertices = <a class="code" href="namespacegraph.html#ad00b2c13c4512574d4adc236ad14a586">VertexList</a>(g);</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        std::sort(vertices.begin(),vertices.end());</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        <span class="keywordflow">do</span> </div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        {</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;            <span class="keyword">auto</span> cstate = <a class="code" href="namespacegraph.html#acd5bddf71f16732a040d2abab7ca1d8e">vertexColoring</a>(g,vertices);</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;            <span class="keywordflow">if</span>(cstate.noOfColorsUsed() &lt; min_color)</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;            {</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;                min_color = cstate.noOfColorsUsed();</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;                min_cstate = cstate;</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;            }</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        } <span class="keywordflow">while</span> (std::next_permutation(vertices.begin(),vertices.end()));</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="comment">//         doneMapping=true;</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        <span class="keywordflow">return</span> min_cstate;</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_ad00b2c13c4512574d4adc236ad14a586"><div class="ttname"><a href="namespacegraph.html#ad00b2c13c4512574d4adc236ad14a586">graph::VertexList</a></div><div class="ttdeci">std::vector&lt; typename Graph::VertexType &gt; VertexList(Graph &amp;g)</div><div class="ttdoc">Returns a list containing names of all the vertices in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="collections_8hpp_source.html#l00034">collections.hpp:34</a></div></div>
<div class="ttc" id="namespacegraph_html_acd5bddf71f16732a040d2abab7ca1d8e"><div class="ttname"><a href="namespacegraph.html#acd5bddf71f16732a040d2abab7ca1d8e">graph::vertexColoring</a></div><div class="ttdeci">ColorState&lt; Graph, typename Graph::VertexType &gt; vertexColoring(Graph &amp;g, std::vector&lt; typename Graph::VertexType &gt; vertices)</div><div class="ttdoc">Returns a map of vertex and corresponding chromatic number for a particular sequence of vertices ...</div><div class="ttdef"><b>Definition:</b> <a href="coloring_8hpp_source.html#l00072">coloring.hpp:72</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7ef1e1be3e79a2b6990ed51b4e7c8e7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int graph::noOfComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns the number of connected components of a graph </li>
</ul>
</p>
<p>Connected Components of a graph are subgraphs which are connected. A pair of vertices are connected if there exists a path between them in a graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="enumeration_8hpp_source.html#l00170">170</a> of file <a class="el" href="enumeration_8hpp_source.html">enumeration.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    {</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        DisjointSet&lt;Graph&gt; ds(g);</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g.begin();i!=g.end();++i)</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> j=g.nbegin(i-&gt;first);j!=g.nend(i-&gt;first);++j)</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;                ds.Union(i-&gt;first,j-&gt;first);</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        std::set&lt;typename Graph::VertexType&gt; s;</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g.begin();i!=g.end();++i)</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;            s.insert(ds.findRoot(i-&gt;first));</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;        <span class="keywordflow">return</span> s.size();</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad9d8db67ff4e058129e82fdc5a66abc0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int graph::nregular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns the degree of each vertex in Graph g if degree of all vertex is equal, returns 0 otherwise </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int k - the degree of each vertex in Graph g if degree of all vertex is equal </dd>
<dd>
0 otherwise </dd></dl>

<p>Definition at line <a class="el" href="enumeration_8hpp_source.html#l00095">95</a> of file <a class="el" href="enumeration_8hpp_source.html">enumeration.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    {</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        <span class="keywordtype">int</span> k=<a class="code" href="namespacegraph.html#a1d26be4aeb4fae8db06762dd366a5714">degree</a>(g,g.begin()-&gt;first);</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> x=g.begin();x!=g.end();x++)</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        {</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;            <span class="keywordflow">if</span> (k!=<a class="code" href="namespacegraph.html#a1d26be4aeb4fae8db06762dd366a5714">degree</a>(g,x-&gt;first))</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;                <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        }</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        <span class="keywordflow">return</span> k;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a1d26be4aeb4fae8db06762dd366a5714"><div class="ttname"><a href="namespacegraph.html#a1d26be4aeb4fae8db06762dd366a5714">graph::degree</a></div><div class="ttdeci">int degree(Graph &amp;g, typename Graph::VertexType v)</div><div class="ttdoc">Returns the total number of edges of Graph::VertexType v in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="enumeration_8hpp_source.html#l00077">enumeration.hpp:77</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab5445f93fca1a98409fe09d12e964b0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int graph::outDegree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns the number of edges directed out of <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> v in Graph g </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - First parameter, a graph object</td></tr>
    <tr><td class="paramname"><a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a></td><td>v - Second parameter, a vertex of Graph g</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int count - the number of edges directed out of <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> v in Graph g </dd></dl>

<p>Definition at line <a class="el" href="enumeration_8hpp_source.html#l00032">32</a> of file <a class="el" href="enumeration_8hpp_source.html">enumeration.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    {</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        <span class="keywordtype">int</span> count=0;</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g.nbegin(v);i!=g.nend(v);++i)</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;            count++;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        <span class="keywordflow">return</span> count;</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a13634637f492ab1746d0bf62771116a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&gt; graph::OutVertexList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns a list containing all the vertices of Graph g having edges originating from Vertex x </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - First parameter, a graph object</td></tr>
    <tr><td class="paramname">typename</td><td><a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> x - Second parameter, a vertex of Graph g</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>map&lt;typename Graph::VertexType&gt; v - variable to store the list </dd></dl>

<p>Definition at line <a class="el" href="collections_8hpp_source.html#l00288">288</a> of file <a class="el" href="collections_8hpp_source.html">collections.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    {</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        std::vector&lt;typename Graph::VertexType&gt; v;</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g.nbegin(x);i!=g.nend(x);++i)</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;            v.push_back(i-&gt;first);</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;        </div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;        <span class="keywordflow">return</span> v;</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af2513261fe79cfc0abee1fe4274737a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int graph::pairCompute </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><ul>
<li>returns the result of function (x+y) *(x+y+1) / 2 +y </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>x - First Parameter</td></tr>
    <tr><td class="paramname">int</td><td>y - Second Parameter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(x+y) *(x+y+1) / 2 +y </dd></dl>

<p>Definition at line <a class="el" href="operations_8hpp_source.html#l00140">140</a> of file <a class="el" href="operations_8hpp_source.html">operations.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    {</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        <span class="keywordflow">return</span> (x+y)*(x+y+1)/2+y;</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a857d0b99072fbb221fb4098e43ae3ea4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;int, int&gt; graph::pairInvert </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><ul>
<li>returns a pair (square root of(8*z+1)-1)/2 - y and z - (w*w+w)/2 </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>z - Parameter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(square root of(8*z+1)-1)/2 - y and z - (w*w+w)/2 </dd></dl>

<p>Definition at line <a class="el" href="operations_8hpp_source.html#l00151">151</a> of file <a class="el" href="operations_8hpp_source.html">operations.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    {</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        <span class="keywordtype">int</span> w = (std::sqrt(8*z+1)-1)/2;</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        <span class="keywordtype">int</span> t = (w*w+w)/2;</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;        <span class="keywordtype">int</span> y = z-t;</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        <span class="keywordtype">int</span> x = w-y;</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        <span class="keywordflow">return</span> {x, y};</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aae686ba4060d119ff11440eca676fcbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&gt; graph::Periphery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns a set of vertices constituting the periphery in Graph g </li>
</ul>
</p>
<p>Periphery is a set of vertices with the maximum eccentricity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>set&lt;typename Graph::VertexType&gt; s - variable to store the peripheries </dd></dl>

<p>Definition at line <a class="el" href="collections_8hpp_source.html#l00241">241</a> of file <a class="el" href="collections_8hpp_source.html">collections.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    {</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;        std::set&lt;typename Graph::VertexType&gt; s;</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;        <span class="keyword">auto</span> e=<a class="code" href="namespacegraph.html#a01eff8481121cd9a87cf25132102e240">EcentricityList</a>(g);</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;        <span class="keyword">auto</span> max=e.begin()-&gt;second;</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=e.begin();i!=e.end();++i)</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;                <span class="keywordflow">if</span>(i-&gt;second&gt;max)</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;                    max=i-&gt;second;</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=e.begin();i!=e.end();++i)</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;            <span class="keywordflow">if</span>(max==i-&gt;second)</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;                s.insert(i-&gt;first);</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        <span class="keywordflow">return</span> s;</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a01eff8481121cd9a87cf25132102e240"><div class="ttname"><a href="namespacegraph.html#a01eff8481121cd9a87cf25132102e240">graph::EcentricityList</a></div><div class="ttdeci">std::map&lt; typename Graph::VertexType, typename Graph::EdgeType &gt; EcentricityList(Graph &amp;g, bool check=true)</div><div class="ttdoc">Returns a map of all vertices in Graph g with their corresponding eccentricities </div><div class="ttdef"><b>Definition:</b> <a href="collections_8hpp_source.html#l00184">collections.hpp:184</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a537e5324e67e666e68331c22a482da23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraph_1_1_m_s_t_state.html">MSTState</a>&lt;<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&gt; graph::Prim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns the Minimum Cost Spanning tree obtained using Prim's ALgorithm </li>
</ul>
</p>
<p>Reference Link - <a href="http://en.wikipedia.org/wiki/Prim%27s_algorithm">Prim's ALgorithm</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph on which Boruvka Algorithm is implemented</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MSTState&lt;Graph&gt; state - holds the Minimum Cost Spanning tree after Prim's Algorithm is applied </dd></dl>

<p>Definition at line <a class="el" href="mst_8hpp_source.html#l00173">173</a> of file <a class="el" href="mst_8hpp_source.html">mst.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    {</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> Graph::VertexType V;</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> Graph::EdgeType E;</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        std::vector &lt;V&gt; v_new=<a class="code" href="namespacegraph.html#ad00b2c13c4512574d4adc236ad14a586">VertexList</a>(g);</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;        MSTState&lt;Graph&gt; state(g);</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;        std::map&lt;V,V&gt; parent;</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        std::map&lt;V,E&gt; cost;</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;        </div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g.begin();i!=g.end();++i)</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;            cost[i-&gt;first]=std::numeric_limits&lt;E&gt;::max();</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        cost[g.begin()-&gt;first]=0;</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        </div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;        PriorityQueue&lt;Graph&gt; pq([&amp;](V x,V y){<span class="keywordflow">return</span> cost[x]&lt;cost[y];},v_new);</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;        </div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;        <span class="keywordflow">while</span>(!pq.empty())</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        {</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;            <span class="keyword">auto</span> u=pq.get();</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g.nbegin(u);i!=g.nend(u);++i)</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;            {</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                <span class="keywordflow">if</span>((g.weight(i-&gt;first,u)&lt;cost[i-&gt;first])&amp;&amp;pq.isElement(i-&gt;first))</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;                {</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;                    parent[i-&gt;first]=u;</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;                    cost[i-&gt;first]=g.weight(i-&gt;first,u);</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;                }</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;            }</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;            pq.heapify();</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        }</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        </div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=parent.begin();i!=parent.end();++i)                   <span class="comment">//creating tree from parent array</span></div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        {</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;            state.insertEdge(i-&gt;first,i-&gt;second, g.weight(i-&gt;first,i-&gt;second));</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;        }</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        </div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        <span class="keywordflow">return</span> state;</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_ad00b2c13c4512574d4adc236ad14a586"><div class="ttname"><a href="namespacegraph.html#ad00b2c13c4512574d4adc236ad14a586">graph::VertexList</a></div><div class="ttdeci">std::vector&lt; typename Graph::VertexType &gt; VertexList(Graph &amp;g)</div><div class="ttdoc">Returns a list containing names of all the vertices in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="collections_8hpp_source.html#l00034">collections.hpp:34</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a239f5d9273230086f3c85e29dc861537"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraph_1_1_adjacency_list.html#a38fb996cc38fcb1cf20fbd601594c900">Graph::EdgeType</a> graph::Radius </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns the radius eccentricity in Graph g </li>
</ul>
</p>
<p>Radius eccentricity is the minimum eccecntricity if a graph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>min- minimum eccentricity </dd></dl>

<p>Definition at line <a class="el" href="enumeration_8hpp_source.html#l00116">116</a> of file <a class="el" href="enumeration_8hpp_source.html">enumeration.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    {</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;        <span class="keyword">auto</span> e=<a class="code" href="namespacegraph.html#a01eff8481121cd9a87cf25132102e240">EcentricityList</a>(g);</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        <span class="keyword">auto</span> min=e.begin()-&gt;second;</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=e.begin();i!=e.end();++i)</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;                <span class="keywordflow">if</span>(i-&gt;second&lt;min)</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;                    min=i-&gt;second;</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        <span class="keywordflow">return</span> min;</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a01eff8481121cd9a87cf25132102e240"><div class="ttname"><a href="namespacegraph.html#a01eff8481121cd9a87cf25132102e240">graph::EcentricityList</a></div><div class="ttdeci">std::map&lt; typename Graph::VertexType, typename Graph::EdgeType &gt; EcentricityList(Graph &amp;g, bool check=true)</div><div class="ttdoc">Returns a map of all vertices in Graph g with their corresponding eccentricities </div><div class="ttdef"><b>Definition:</b> <a href="collections_8hpp_source.html#l00184">collections.hpp:184</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5c41719547528ea22af228adcd69668f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int graph::Size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns number of edges in Graph g </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="enumeration_8hpp_source.html#l00017">17</a> of file <a class="el" href="enumeration_8hpp_source.html">enumeration.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    {</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacegraph.html#ae8dd696bb3483de793bf5027f4f25474">EdgeList</a>(g,<span class="keyword">false</span>).size();</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_ae8dd696bb3483de793bf5027f4f25474"><div class="ttname"><a href="namespacegraph.html#ae8dd696bb3483de793bf5027f4f25474">graph::EdgeList</a></div><div class="ttdeci">std::vector&lt; std::tuple&lt; typename Graph::VertexType, typename Graph::VertexType, typename Graph::EdgeType &gt; &gt; EdgeList(Graph &amp;g, bool duplicate=true)</div><div class="ttdoc">Returns a list containing of adjacent vertices with edge weights </div><div class="ttdef"><b>Definition:</b> <a href="collections_8hpp_source.html#l00064">collections.hpp:64</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a347482999e282edb2e82de37cad981de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::tuple &lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>, typename <a class="el" href="classgraph_1_1_adjacency_list.html#a38fb996cc38fcb1cf20fbd601594c900">Graph::EdgeType</a> &gt; &gt; graph::sortedEdgeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>duplicate</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>eturns a list containing of adjacent vertices with edge weights </li>
</ul>
</p>
<p>This function returns a list containing pairs of vertices which are connected by an edge. The list also contains the edge weights for each edge. The list is sorted by edge weight in ascending order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - First Parameter, a graph object</td></tr>
    <tr><td class="paramname">bool</td><td>duplicate - Second Parameter, to check for duplicate edges</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;std::tuple&lt;typename Graph::VertexType,typename Graph::VertexType,typename Graph::EdgeType&gt;&gt; e - variable to store the sorted edge list </dd></dl>

<p>Definition at line <a class="el" href="collections_8hpp_source.html#l00126">126</a> of file <a class="el" href="collections_8hpp_source.html">collections.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    {</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;         std::vector&lt;std::tuple&lt;typename Graph::VertexType,typename Graph::VertexType,typename Graph::EdgeType&gt;&gt; e=<a class="code" href="namespacegraph.html#ae8dd696bb3483de793bf5027f4f25474">EdgeList</a>(g,duplicate);</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;         std::sort(e.begin(),e.end(),sortComparison&lt;Graph&gt;);</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;         <span class="keywordflow">return</span> e;</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_ae8dd696bb3483de793bf5027f4f25474"><div class="ttname"><a href="namespacegraph.html#ae8dd696bb3483de793bf5027f4f25474">graph::EdgeList</a></div><div class="ttdeci">std::vector&lt; std::tuple&lt; typename Graph::VertexType, typename Graph::VertexType, typename Graph::EdgeType &gt; &gt; EdgeList(Graph &amp;g, bool duplicate=true)</div><div class="ttdoc">Returns a list containing of adjacent vertices with edge weights </div><div class="ttdef"><b>Definition:</b> <a href="collections_8hpp_source.html#l00064">collections.hpp:64</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a80cf30b107915cae80906b4fcda2e5b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> graph::symmetric_difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns symmetric_difference of two Graph datastructures </li>
</ul>
</p>
<p>Symmetric difference of two graphs contains the vertices present in first graph and not in second graph and vice versa. It contains the edges that connect two vertices of first graph that are not connected by an edge in the second graph and vice versa.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g1 - First parameter, a graph datastructure</td></tr>
    <tr><td class="paramname">Graph</td><td>g2 - Second parameter, a graph datastructure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Graph result - Variable to store resultant symmetric_difference of Graph g1 and Graph g2 </dd></dl>

<p>Definition at line <a class="el" href="operations_8hpp_source.html#l00108">108</a> of file <a class="el" href="operations_8hpp_source.html">operations.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    {</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        <a class="code" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> result;</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g1.begin();i!=g1.end();++i)</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;            <span class="keywordflow">if</span>(!<a class="code" href="namespacegraph.html#ac94693eb5b7a9ba65b1da69d8ecde02b">isVertex</a>(g2,i-&gt;first))</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                result.<a class="code" href="classgraph_1_1_adjacency_list.html#ad182c37f701316c35311e7fcd82df0a1">insertVertex</a>(i-&gt;first);</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g2.begin();i!=g2.end();++i)</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;            <span class="keywordflow">if</span>(!<a class="code" href="namespacegraph.html#ac94693eb5b7a9ba65b1da69d8ecde02b">isVertex</a>(g1,i-&gt;first))</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;                result.insertVertex(i-&gt;first);</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        </div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g1.begin();i!=g1.end();++i)</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> j=g1.nbegin(i-&gt;first);j!=g1.nend(i-&gt;first);++j)</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;                <span class="keywordflow">if</span>(<a class="code" href="namespacegraph.html#ac94693eb5b7a9ba65b1da69d8ecde02b">isVertex</a>(result,i-&gt;first) &amp;&amp; <a class="code" href="namespacegraph.html#ac94693eb5b7a9ba65b1da69d8ecde02b">isVertex</a>(result,j-&gt;first))</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;                    <span class="keywordflow">if</span>(!<a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(g2,i-&gt;first,j-&gt;first))</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;                        result.insertEdge(i-&gt;first,j-&gt;first,j-&gt;second);</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g2.begin();i!=g2.end();++i)</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> j=g2.nbegin(i-&gt;first);j!=g2.nend(i-&gt;first);++j)</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;                <span class="keywordflow">if</span>(<a class="code" href="namespacegraph.html#ac94693eb5b7a9ba65b1da69d8ecde02b">isVertex</a>(result,i-&gt;first) &amp;&amp; <a class="code" href="namespacegraph.html#ac94693eb5b7a9ba65b1da69d8ecde02b">isVertex</a>(result,j-&gt;first))</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;                    <span class="keywordflow">if</span>(!<a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(g1,i-&gt;first,j-&gt;first))</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;                        result.insertEdge(i-&gt;first,j-&gt;first,j-&gt;second);</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;                    </div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a79acfc9c3ac45e39bf873e19eff98fab"><div class="ttname"><a href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">graph::Graph</a></div><div class="ttdeci">AdjacencyList&lt; VertexType, EdgeType &gt; Graph</div><div class="ttdoc">using Graph for AdjacencyList<VertexType,EdgeType> </div><div class="ttdef"><b>Definition:</b> <a href="graph_8hpp_source.html#l00017">graph.hpp:17</a></div></div>
<div class="ttc" id="classgraph_1_1_adjacency_list_html_ad182c37f701316c35311e7fcd82df0a1"><div class="ttname"><a href="classgraph_1_1_adjacency_list.html#ad182c37f701316c35311e7fcd82df0a1">graph::AdjacencyList::insertVertex</a></div><div class="ttdeci">void insertVertex(const VertexType &amp;v)</div><div class="ttdoc">function to insert a vertex to a graph </div><div class="ttdef"><b>Definition:</b> <a href="adjlist_8hpp_source.html#l00062">adjlist.hpp:62</a></div></div>
<div class="ttc" id="namespacegraph_html_ac94693eb5b7a9ba65b1da69d8ecde02b"><div class="ttname"><a href="namespacegraph.html#ac94693eb5b7a9ba65b1da69d8ecde02b">graph::isVertex</a></div><div class="ttdeci">bool isVertex(Graph &amp;g, typename Graph::VertexType x)</div><div class="ttdoc">Returns true if Graph::VertexType x is a vertex of Graph g, false otherwise </div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00028">predicates.hpp:28</a></div></div>
<div class="ttc" id="namespacegraph_html_a9e003e6fc1c423c859fc0a98cc34a2c0"><div class="ttname"><a href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">graph::isAdjacent</a></div><div class="ttdeci">bool isAdjacent(Graph &amp;g, typename Graph::VertexType x, typename Graph::VertexType y)</div><div class="ttdoc">Returns true if Graph::VertexType x and Graph::VertexType y are adjacent in Graph g...</div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00045">predicates.hpp:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a27ec4176d88500a4a129ac2a3361a9ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> graph::Union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns union of two Graph datastructures </li>
</ul>
</p>
<p>A union of two graphs contains all the vertices of both graphs and all corresponding edges from both graphs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g1 - First parameter, a graph datastructure</td></tr>
    <tr><td class="paramname">Graph</td><td>g2 - Second parameter, a graph datastructure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Graph result - Variable to store resultant Union of Graph g1 and Graph g2 </dd></dl>

<p>Definition at line <a class="el" href="operations_8hpp_source.html#l00027">27</a> of file <a class="el" href="operations_8hpp_source.html">operations.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    {</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        <a class="code" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> result;</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g1.begin();i!=g1.end();++i)</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;            result.<a class="code" href="classgraph_1_1_adjacency_list.html#ad182c37f701316c35311e7fcd82df0a1">insertVertex</a>(i-&gt;first);</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g2.begin();i!=g2.end();++i)</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;            result.insertVertex(i-&gt;first);</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g1.begin();i!=g1.end();++i)</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> j=g1.nbegin(i-&gt;first);j!=g1.nend(i-&gt;first);++j)</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;                result.insertEdge(i-&gt;first,j-&gt;first,j-&gt;second);</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i=g2.begin();i!=g2.end();++i)</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> j=g2.nbegin(i-&gt;first);j!=g2.nend(i-&gt;first);++j)</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;                <span class="keywordflow">if</span>(!<a class="code" href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">isAdjacent</a>(result,i-&gt;first,j-&gt;first))</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;                    result.insertEdge(i-&gt;first,j-&gt;first,j-&gt;second);</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;                        </div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;        <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a79acfc9c3ac45e39bf873e19eff98fab"><div class="ttname"><a href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">graph::Graph</a></div><div class="ttdeci">AdjacencyList&lt; VertexType, EdgeType &gt; Graph</div><div class="ttdoc">using Graph for AdjacencyList<VertexType,EdgeType> </div><div class="ttdef"><b>Definition:</b> <a href="graph_8hpp_source.html#l00017">graph.hpp:17</a></div></div>
<div class="ttc" id="classgraph_1_1_adjacency_list_html_ad182c37f701316c35311e7fcd82df0a1"><div class="ttname"><a href="classgraph_1_1_adjacency_list.html#ad182c37f701316c35311e7fcd82df0a1">graph::AdjacencyList::insertVertex</a></div><div class="ttdeci">void insertVertex(const VertexType &amp;v)</div><div class="ttdoc">function to insert a vertex to a graph </div><div class="ttdef"><b>Definition:</b> <a href="adjlist_8hpp_source.html#l00062">adjlist.hpp:62</a></div></div>
<div class="ttc" id="namespacegraph_html_a9e003e6fc1c423c859fc0a98cc34a2c0"><div class="ttname"><a href="namespacegraph.html#a9e003e6fc1c423c859fc0a98cc34a2c0">graph::isAdjacent</a></div><div class="ttdeci">bool isAdjacent(Graph &amp;g, typename Graph::VertexType x, typename Graph::VertexType y)</div><div class="ttdoc">Returns true if Graph::VertexType x and Graph::VertexType y are adjacent in Graph g...</div><div class="ttdef"><b>Definition:</b> <a href="predicates_8hpp_source.html#l00045">predicates.hpp:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a662e07d0caaf6aab284fb82cc3af5c2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraph_1_1_vertex_attribute.html">VertexAttribute</a>&lt;<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>, int&gt; graph::VertexColorAssignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns a mapping of vertices and their corresponding colours </li>
</ul>
</p>
<p>this employs someheuristics to reduce complexity. the vertex colouring is not guaranteed to be done using the minimum number of colours possible everytime.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph&amp;</td><td>g - Parameter, a graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VertexAttribute&lt;Graph, int&gt; vattr - the mapping of vertices and their colours </dd></dl>

<p>Definition at line <a class="el" href="collections_8hpp_source.html#l00354">354</a> of file <a class="el" href="collections_8hpp_source.html">collections.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;    {</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;        <span class="keyword">auto</span> state = <a class="code" href="namespacegraph.html#ad0a694b54f33b86d8783c64c13f5d456">WelshPowellColoring</a>(g);</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;        VertexAttribute&lt;Graph, int&gt; vattr(state.getColorMap());</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;        <span class="keywordflow">return</span> vattr;</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_ad0a694b54f33b86d8783c64c13f5d456"><div class="ttname"><a href="namespacegraph.html#ad0a694b54f33b86d8783c64c13f5d456">graph::WelshPowellColoring</a></div><div class="ttdeci">ColorState&lt; Graph, typename Graph::VertexType &gt; WelshPowellColoring(Graph &amp;g)</div><div class="ttdoc">Vertex Coloring algorithm using some heuristics. Determines the map of vertices and corresponding chr...</div><div class="ttdef"><b>Definition:</b> <a href="coloring_8hpp_source.html#l00141">coloring.hpp:141</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acd5bddf71f16732a040d2abab7ca1d8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraph_1_1_color_state.html">ColorState</a>&lt;<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&gt; graph::vertexColoring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a> &gt;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns a map of vertex and corresponding chromatic number for a particular sequence of vertices </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>&amp;g - First Parameter, a graph object</td></tr>
    <tr><td class="paramname">std::vector&lt;typename</td><td><a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a>&gt; vertices - Second parameter, a list of vertices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ColorState&lt;Graph, typename Graph::VertexType&gt; cstate - map of vertex and corresponding chromatic number for a particular sequence of vertices </dd></dl>

<p>Definition at line <a class="el" href="coloring_8hpp_source.html#l00072">72</a> of file <a class="el" href="coloring_8hpp_source.html">coloring.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    {</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        std::map&lt;typename Graph::VertexType,int&gt; tempmap;</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        <span class="keywordtype">int</span> ncolor=0;</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        <span class="keywordflow">for</span>(uint i=0;i&lt;vertices.size();++i)</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;        {</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;            std::vector&lt;int&gt; used;</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> j=g.nbegin(vertices[i]);j!=g.nend(vertices[i]);++j)</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;            {</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;                <span class="keyword">auto</span> it=tempmap.find(j-&gt;first);</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;                <span class="keywordflow">if</span>(it!=tempmap.end())</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;                    used.push_back(it-&gt;second);</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;            }</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> c=1;c&lt;=ncolor+1;++c)</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;                <span class="keywordflow">if</span>(std::find(used.begin(),used.end(),c)==used.end())</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                {</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;                    tempmap[vertices[i]]=c;</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;                    <span class="keywordflow">if</span>(c==ncolor+1)</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;                        ncolor++;</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;                    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;                }</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;        }</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;        ColorState&lt;Graph, typename Graph::VertexType&gt; cstate(g,tempmap,ncolor);</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        <span class="keywordflow">return</span> cstate;</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a239b80d07aa07ae2eadbbb9731f40b43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> graph::VertexDeletionSubgraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns the graph after deleting the vertex x of graph g1 </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g1 - Parameter, a graph datastructure</td></tr>
    <tr><td class="paramname">typename</td><td><a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a> x - Second Parameter, a vertex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>g1 - the graph after removing vertex x </dd></dl>

<p>Definition at line <a class="el" href="operations_8hpp_source.html#l00249">249</a> of file <a class="el" href="operations_8hpp_source.html">operations.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    {</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        g1.removeVertex(x);</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        <span class="keywordflow">return</span> g1;</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad00b2c13c4512574d4adc236ad14a586"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&gt; graph::VertexList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Returns a list containing names of all the vertices in Graph g </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g - Parameter, a graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;typename Graph::VertexType&gt; v - vector to store the list </dd></dl>

<p>Definition at line <a class="el" href="collections_8hpp_source.html#l00034">34</a> of file <a class="el" href="collections_8hpp_source.html">collections.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    {</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        std::vector&lt;typename Graph::VertexType&gt; v;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        <a class="code" href="namespacegraph.html#a12612233d1f03f2593419ab879be2d91">VisitVertices</a>(g,[&amp;v](<span class="keyword">typename</span> Graph::VertexType x){v.push_back(x);}); <span class="comment">// put auto after enabling c++11</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        <span class="keywordflow">return</span> v;</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a12612233d1f03f2593419ab879be2d91"><div class="ttname"><a href="namespacegraph.html#a12612233d1f03f2593419ab879be2d91">graph::VisitVertices</a></div><div class="ttdeci">void VisitVertices(Graph &amp;g, F f)</div><div class="ttdoc">function to visit all vertices of a graph </div><div class="ttdef"><b>Definition:</b> <a href="visitors_8hpp_source.html#l00018">visitors.hpp:18</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0ee632989a4fe4010b653e350d54afc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void graph::VisitEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>function to visit all edges of a graph </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph&amp;</td><td>g - First Parameter, a graph datastructure</td></tr>
    <tr><td class="paramname">F</td><td>f - Second Parameter, a callback function </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="visitors_8hpp_source.html#l00049">49</a> of file <a class="el" href="visitors_8hpp_source.html">visitors.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    {</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        <a class="code" href="namespacegraph.html#a12612233d1f03f2593419ab879be2d91">VisitVertices</a></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        (g, </div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;            [&amp;g,&amp;f](<span class="keyword">typename</span> Graph::VertexType x)</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;            {</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;                <a class="code" href="namespacegraph.html#acb243df0343a7f117a0de2817792de58">VisitNeighbours</a></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;                (</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;                    g,x,</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;                    [&amp;g,&amp;f,&amp;x](<span class="keyword">typename</span> Graph::VertexType y){f(x,y);}</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                );</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;            }</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        );</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_a12612233d1f03f2593419ab879be2d91"><div class="ttname"><a href="namespacegraph.html#a12612233d1f03f2593419ab879be2d91">graph::VisitVertices</a></div><div class="ttdeci">void VisitVertices(Graph &amp;g, F f)</div><div class="ttdoc">function to visit all vertices of a graph </div><div class="ttdef"><b>Definition:</b> <a href="visitors_8hpp_source.html#l00018">visitors.hpp:18</a></div></div>
<div class="ttc" id="namespacegraph_html_acb243df0343a7f117a0de2817792de58"><div class="ttname"><a href="namespacegraph.html#acb243df0343a7f117a0de2817792de58">graph::VisitNeighbours</a></div><div class="ttdeci">void VisitNeighbours(Graph &amp;g, typename Graph::VertexType v, F f)</div><div class="ttdoc">function to visit all neighbours of a vertex of a graph </div><div class="ttdef"><b>Definition:</b> <a href="visitors_8hpp_source.html#l00035">visitors.hpp:35</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acb243df0343a7f117a0de2817792de58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void graph::VisitNeighbours </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>function to visit all neighbours of a vertex of a graph </li>
</ul>
</p>
<p>a neighbour of a vertex is another vertex which shares an edge</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph&amp;</td><td>g - First Parameter, a graph datastructure</td></tr>
    <tr><td class="paramname"><a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361" title="Vertex. ">Graph::VertexType</a></td><td>v - Second Parameter, a vertex</td></tr>
    <tr><td class="paramname">F</td><td>f - Third Parameter, a callback function </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="visitors_8hpp_source.html#l00035">35</a> of file <a class="el" href="visitors_8hpp_source.html">visitors.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    {</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> it = g.nbegin(v); it != g.nend(v); ++it)</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;            f(it-&gt;first);</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a12612233d1f03f2593419ab879be2d91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void graph::VisitVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>function to visit all vertices of a graph </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph&amp;</td><td>g - First Parameter, a graph datastructure</td></tr>
    <tr><td class="paramname">F</td><td>f - Second Parameter, a callback function </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="visitors_8hpp_source.html#l00018">18</a> of file <a class="el" href="visitors_8hpp_source.html">visitors.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    {</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> it = g.begin(); it != g.end(); ++it)</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;            f(it-&gt;first);</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad0a694b54f33b86d8783c64c13f5d456"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraph_1_1_color_state.html">ColorState</a>&lt;<a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a>, typename <a class="el" href="classgraph_1_1_adjacency_list.html#ac529b79eef243d95e8e372a015fbd361">Graph::VertexType</a>&gt; graph::WelshPowellColoring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegraph.html#a79acfc9c3ac45e39bf873e19eff98fab">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Vertex Coloring algorithm using some heuristics. Determines the map of vertices and corresponding chromatic number for all possible sequence of vertices </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph&amp;</td><td>g - Parameter, a graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ColorState&lt;Graph, typename Graph::VertexType&gt; - map of vertices and corresponding chromatic number for all possible sequence of vertices Reference Link <a href="http://comjnl.oxfordjournals.org/content/10/1/85.full.pdf+html">WelshPowell </a> </dd></dl>

<p>Definition at line <a class="el" href="coloring_8hpp_source.html#l00141">141</a> of file <a class="el" href="coloring_8hpp_source.html">coloring.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    {</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> Graph::VertexType V;</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;        <span class="keyword">auto</span> d_list = <a class="code" href="namespacegraph.html#a0dec8a130a4c41da242b1bdd9ad254a3">DegreeMap</a>(g);</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        <span class="keyword">auto</span> vlist = <a class="code" href="namespacegraph.html#ad00b2c13c4512574d4adc236ad14a586">VertexList</a>(g);</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        std::sort(vlist.begin(),vlist.end(),[&amp;](V x,V y){<span class="keywordflow">return</span> d_list[x]&gt;d_list[y];});</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacegraph.html#acd5bddf71f16732a040d2abab7ca1d8e">vertexColoring</a>(g, vlist);</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    }</div>
<div class="ttc" id="namespacegraph_html_ad00b2c13c4512574d4adc236ad14a586"><div class="ttname"><a href="namespacegraph.html#ad00b2c13c4512574d4adc236ad14a586">graph::VertexList</a></div><div class="ttdeci">std::vector&lt; typename Graph::VertexType &gt; VertexList(Graph &amp;g)</div><div class="ttdoc">Returns a list containing names of all the vertices in Graph g </div><div class="ttdef"><b>Definition:</b> <a href="collections_8hpp_source.html#l00034">collections.hpp:34</a></div></div>
<div class="ttc" id="namespacegraph_html_acd5bddf71f16732a040d2abab7ca1d8e"><div class="ttname"><a href="namespacegraph.html#acd5bddf71f16732a040d2abab7ca1d8e">graph::vertexColoring</a></div><div class="ttdeci">ColorState&lt; Graph, typename Graph::VertexType &gt; vertexColoring(Graph &amp;g, std::vector&lt; typename Graph::VertexType &gt; vertices)</div><div class="ttdoc">Returns a map of vertex and corresponding chromatic number for a particular sequence of vertices ...</div><div class="ttdef"><b>Definition:</b> <a href="coloring_8hpp_source.html#l00072">coloring.hpp:72</a></div></div>
<div class="ttc" id="namespacegraph_html_a0dec8a130a4c41da242b1bdd9ad254a3"><div class="ttname"><a href="namespacegraph.html#a0dec8a130a4c41da242b1bdd9ad254a3">graph::DegreeMap</a></div><div class="ttdeci">std::map&lt; typename Graph::VertexType, int &gt; DegreeMap(Graph &amp;g)</div><div class="ttdoc">Returns a list containing all the vertices of Graph g alongwith the total number of edges of each ver...</div><div class="ttdef"><b>Definition:</b> <a href="collections_8hpp_source.html#l00143">collections.hpp:143</a></div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacegraph.html">graph</a></li>
    <li class="footer">Generated on Sun Oct 11 2015 19:51:42 for SPIDER by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
